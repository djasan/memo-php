Jusque-lÃ , vous n'avez travaillÃ© que sur une seule table Ã  la fois. Dans la pratique, vous aurez certainement plusieurs tables dans votre base, dont la plupart seront interconnectÃ©es.

Cela vous permettra :

    de mieux dÃ©couper vos informations ;

    d'Ã©viter des rÃ©pÃ©titions ;

    et de rendre ainsi vos donnÃ©es plus faciles Ã  gÃ©rer.

Par exemple, dans notre table recipes  , on rÃ©pÃ¨te Ã  chaque fois l'e-mail du contributeur de la recette alors qu'il est dÃ©jÃ  dans la table users .

Et si on ajoute une gestion des commentaires sur la page d'une recette, alors il faudra lier le commentaire Ã  un utilisateur et Ã  une recette.

Pour bien comprendre l'intÃ©rÃªt et la notion de jointure, c'est la fonctionnalitÃ© que vous allez mettre en place dans ce chapitre : suivez le guide !
ModÃ©lisez une relation

Si on considÃ¨re une page qui affiche la recette avec la possibilitÃ© que les utilisateurs puissent commenter, voire Ã©valuer la recette, alors un commentaire a les propriÃ©tÃ©s suivantes :

    un identifiant unique ;

    une recette ;

    un auteur ;

    une date de publication ;

    une note (disons de 0 Ã  5).

Si on se reprÃ©sente la table "comments", elle ressemblerait Ã  ceci :

id
	

recipe
	

author
	

created_at
	

ranking
	

comment

1
	

Cassoulet
	

mickael.andrieu@exemple.com
	

03-08-2021 18:00:00
	

2
	

Bof ğŸ˜

2
	

Cassoulet
	

laurene.castor@exemple.com
	

01-08-2021 12:00:00
	

4
	

Super recette ğŸ˜

3
	

Couscous
	

mathieu.nebra@exemple.com
	

30-08-2021 12:00:00
	

0
	

Pas bon du tout ! ğŸ¤¢

4
	

Couscous
	

mickael.andrieu@exemple.com
	

...
	

...
	

...

Comme vous le voyez, l'auteur et le nom de la recette vont apparaÃ®tre autant de fois qu'il y a de commentaires d'un auteur ou sur une recette en particulier !

Pourtant, vous aviez dÃ©jÃ  centralisÃ© les informations sur les utilisateurs dans la table users  :

user_id
	

full_name
	

email
	

password
	

age

1
	

MickaÃ«l Andrieu
	

mickael.andrieu@exemple.com
	

...
	

34

2
	

LaurÃ¨ne Castor
	

laurene.castor@exemple.com
	

...
	

28

3
	

Mathieu Nebra
	

...
	

...
	

...

Ã€ l'aide de MySQL et grÃ¢ce au champ user_id, vous Ãªtes dÃ©jÃ  capable de rÃ©cupÃ©rer toutes les informations sur un utilisateur sans avoir Ã  les Ã©crire dans une autre table.

Pour rappel :

# Toutes les informations sur LaurÃ¨ne !

SELECT * from users WHERE user_id = 2

Maintenant, il faut modifier la structure de la table comments pour faire rÃ©fÃ©rence aux donnÃ©es disponibles dans la table users  .

Pour cela, le mieux est de crÃ©er un champ user_id dans la table comments  qui fait rÃ©fÃ©rence au champ user_id dans la table  users  :

id
	

recipe
	

user_id
	

created_at
	

ranking
	

comment

1
	

Cassoulet
	

1
	

03-08-2021 18:00:00
	

2
	

Bof ğŸ˜

2
	

Cassoulet
	

2
	

01-08-2021 12:00:00
	

4
	

Super recette ğŸ˜

3
	

Couscous
	

3
	

30-08-2021 12:00:00
	

0
	

Pas bon du tout ! ğŸ¤¢

4
	

Couscous
	

1
	

...
	

...
	

...

MySQL sait donc que le user_id   de valeur 1 dans la table comments correspond Ã  MickaÃ«l ?

Non, il ne le sait pas. Il ne voit que des nombres et il ne fait pas la relation entre les deux tables. Il va falloir lui expliquer cette relation dans une requÃªte SQL : on va faire ce qu'on appelle une jointure entre les deux tables.
Comprenez le principe de jointure

Nous avons donc maintenant deux tables :

    comments 

    users  

Les informations sont sÃ©parÃ©es dans des tables diffÃ©rentes, et c'est bien. Cela Ã©vite de dupliquer des informations sur le disque.

Cependant, lorsqu'on rÃ©cupÃ¨re la liste des commentaires, si on souhaite obtenir le nom des auteurs, il faut adapter la requÃªte pour rÃ©cupÃ©rer aussi les informations issues de la table users  .

Pour cela, on doit faire une jointure.

Il existe plusieurs types de jointures, qui nous permettent de choisir exactement les donnÃ©es que l'on veut rÃ©cupÃ©rer. Je vous propose d'en dÃ©couvrir deux, les plus importantes :

    Les jointures internes : elles ne sÃ©lectionnent que les donnÃ©es qui ont une correspondance entre les deux tables.

    Les jointures externes : elles sÃ©lectionnent toutes les donnÃ©es, mÃªme si certaines n'ont pas de correspondance dans l'autre table.

Il est important de bien comprendre la diffÃ©rence entre une jointure interne et une jointure externe.

Pour cela, imaginons que nous ayons une 4e personne dans la table des utilisateurs, un certain Manuels Vache, qui n'a jamais publiÃ© de commentaires :

user_id
	

full_name
	

email
	

password
	

age

1
	

MickaÃ«l Andrieu
	

mickael.andrieu@exemple.com
	

...
	

34

2
	

LaurÃ¨ne Castor
	

laurene.castor@exemple.com
	

...
	

28

3
	

Mathieu Nebra
	

...
	

...
	

...

4
	

Manuels Vache
	

...
	

...
	

58

Manuels Vache est rÃ©fÃ©rencÃ© dans la table users  mais il n'apparaÃ®t nulle part dans la table comments  car il n'a jamais commentÃ©.

    Si vous rÃ©cupÃ©rez les donnÃ©es des deux tables Ã  l'aide d'une jointure interne, Manuels n'apparaÃ®tra pas dans les rÃ©sultats de la requÃªte. La jointure interne force les donnÃ©es d'une table Ã  avoir une correspondance dans l'autre.

    Si vous rÃ©cupÃ©rez les donnÃ©es des deux tables Ã  l'aide d'une jointure externe, vous aurez toutes les donnÃ©es de la table des utilisateurs, mÃªme s'il n'y a pas de correspondance dans l'autre table des commentaires ; donc Manuels, qui pourtant n'a jamais commentÃ©, apparaÃ®tra.

La jointure externe est donc plus complÃ¨te car elle est capable de rÃ©cupÃ©rer plus d'informations, tandis que la jointure interne est plus stricte car elle ne rÃ©cupÃ¨re que les donnÃ©es qui ont une Ã©quivalence dans l'autre table.

Voici par exemple les donnÃ©es que l'on rÃ©cupÃ¨rerait avec une jointure interne :

full_name
	

comment

MickaÃ«l Andrieu
	

Bof ğŸ˜

LaurÃ¨ne Castor
	

Super recette ğŸ˜

Mathieu Nebra
	

Pas bon du tout ! ğŸ¤¢

â€¦
	

â€¦

En revanche, avec une jointure externe, on aurait :

full_name
	

comment

MickaÃ«l Andrieu
	

Bof ğŸ˜

LaurÃ¨ne Castor
	

Super recette ğŸ˜

Mathieu Nebra
	

Pas bon du tout ! ğŸ¤¢

Manuels Vache
	

NULL

...
	

...

Manuels apparaÃ®t dÃ©sormais. Comme il n'a jamais commentÃ©, la valeur associÃ©e est  NULL  .

Nous allons maintenant voir comment rÃ©aliser ces deux types de jointures en pratique.
Effectuez des jointures internes

Une jointure interne peut Ãªtre effectuÃ©e Ã  l'aide du mot-clÃ© JOIN :

# Liste des noms et commentaires associÃ©s

SELECT u.full_name, c.comment

FROM users u

INNER JOIN comments c

ON u.user_id = c.user_id

Cette fois, on rÃ©cupÃ¨re les donnÃ©es depuis une table principale (ici, users ) et on fait une jointure interne ( INNER JOIN  ) avec une autre table ( comments  ).

La liaison entre les champs est faite dans la clause ON un peu plus loin.

Si vous voulez :

    filtrer ( WHERE  ),

    ordonner ( ORDER BY  )

    ou limiter les rÃ©sultats ( LIMIT  ),

â€¦ vous devez le faire Ã  la fin de la requÃªte, aprÃ¨s le Â« ON u.user_id = c.user_id Â».

Par exemple :

# Liste des noms et commentaires associÃ©s

# Ã  la recette Cassoulet

# du plus vieux au plus rÃ©cent

# limitÃ© Ã  10

SELECT u.full_name, c.comment

FROM users u

INNER JOIN comments c

ON u.user_id = c.user_id

WHERE u.recipe = "Cassoulet"

ORDER BY c.created_at DESC

LIMIT 10

Traduction (inspirez un grand coup avant de lire) :

    Â« RÃ©cupÃ¨re le commentaire et le nom de l'auteur dans les tables users et comments , la liaison entre les tables se fait sur le champ user_id , prends uniquement les commentaires concernant la recette de Cassoulet, trie-les par date dÃ©croissante et ne prends que les 10 premiers. Â»

Il faut s'accrocher avec des requÃªtes de cette taille-lÃ  !
Effectuez des jointures externes

Les jointures externes permettent de rÃ©cupÃ©rer toutes les donnÃ©es, mÃªme celles qui n'ont pas de correspondance.

On pourra ainsi obtenir Manuels Vache dans la liste, mÃªme s'il n'a jamais commentÃ©.

Cette fois, la seule syntaxe disponible est Ã  base de JOIN  .

Il y a deux Ã©critures Ã  connaÃ®tre :

    LEFT JOIN 

    RIGHT JOIN 

Cela revient pratiquement au mÃªme, avec une subtile diffÃ©rence que nous allons voir.
RÃ©cupÃ©rez toute la table de gauche avec LEFT JOIN

Reprenons la jointure Ã  base de INNER JOIN et remplaÃ§ons tout simplement INNER par LEFT :

# Liste des noms et commentaires associÃ©s

SELECT u.full_name, c.comment

FROM users u

LEFT JOIN comments c

ON u.user_id = c.user_id

users  est appelÃ©e la Â« table de gauche Â» et comments  la Â« table de droite Â».

Le LEFT JOIN  demande Ã  rÃ©cupÃ©rer tout le contenu de la table de gauche, donc tous les utilisateurs, mÃªme si ces derniers n'ont pas d'Ã©quivalence dans la table comments :

full_name
	

comment

MickaÃ«l Andrieu
	

Bof ğŸ˜

LaurÃ¨ne Castor
	

Super recette ğŸ˜

Mathieu Nebra
	

Pas bon du tout ! ğŸ¤¢

Manuels Vache
	

NULL

...
	

...

Manuels apparaÃ®t dÃ©sormais dans les rÃ©sultats de la requÃªte grÃ¢ce Ã  la jointure externe. Comme il n'a jamais commentÃ©, la colonne du commentaire est vide.
RÃ©cupÃ©rez toute la table de droite avec RIGHT JOIN

Le RIGHT JOIN  demande Ã  rÃ©cupÃ©rer toutes les donnÃ©es de la table dite Â« de droite Â», mÃªme si celle-ci n'a pas d'Ã©quivalent dans l'autre table.

Prenons la requÃªte suivante :

# Liste des noms et commentaires associÃ©s

SELECT u.full_name, c.comment

FROM users u

RIGHT JOIN comments c

ON u.user_id = c.user_id

La table de droite est Â« comments Â». On rÃ©cupÃ¨rerait donc tous les commentaires, mÃªme ceux qui n'ont pas d'auteur associÃ©.

Comment est-ce possible qu'un commentaire n'ait pas d'utilisateur associÃ© ?

Il y a deux cas possibles :

    Soit le champ user_id  contient une valeur qui n'a pas d'Ã©quivalent dans la table  users  , par exemple Â« 56 Â».

    Soit le champ user_id vaut NULL  , c'est-Ã -dire que la personne qui a commentÃ© a souhaitÃ© rester anonyme, par exemple. 

Le projet fil rouge ne permet pas Ã  un visiteur de publier un commentaire sans s'authentifier Ã  l'aide d'un e-mail, mais rien ne vous empÃªche de dÃ©velopper cette fonctionnalitÃ© : c'est votre projet, aprÃ¨s tout !

On obtiendrait donc les donnÃ©es exposÃ©es dans le tableau suivant :

full_name
	

comment

MickaÃ«l Andrieu
	

Bof ğŸ˜

LaurÃ¨ne Castor
	

Super recette ğŸ˜

Mathieu Nebra
	

Pas bon du tout ! ğŸ¤¢

NULL
	

Le plat est ressorti cramÃ© Ã  mon premier essai ğŸ˜¥

...
	

...

D'accord, mais est-ce qu'il ne faudrait pas faire la mÃªme chose avec la table recipes ?

Si, complÃ¨tement ! Ã€ ce moment-lÃ , vous ferez non pas une mais deux jointures !

Par exemple, la liste des utilisateurs, commentaires et nom de recettes, comme ceci :

SELECT u.full_name, c.comment, r.title

FROM users u

JOIN comments c

    ON u.user_id = c.user_id

JOIN recipes r

    ON c.recipe_id = r.recipe_id

Vous obtiendriez un rÃ©sultat Ã©quivalent Ã  celui-ci :

full_name
	

comment
	

title

MickaÃ«l Andrieu
	

Bof ğŸ˜
	

Cassoulet

LaurÃ¨ne Castor
	

Super recette ğŸ˜
	

Cassoulet

Mathieu Nebra
	

Pas bon du tout ! ğŸ¤¢
	

Couscous

â€¦
	

â€¦
	

 

Envie d'expÃ©rimenter la fonctionnalitÃ© de gestion des commentaires ?

Trouvez sur Github la version mise Ã  jour du projet fil rouge !
En rÃ©sumÃ©

    Les bases de donnÃ©es permettent d'associer plusieurs tables entre elles.

    Une table peut contenir les id d'une autre table, ce qui permet de faire la liaison entre les deux.

    Pour rassembler les informations au moment de la requÃªte, on effectue des jointures.

    On rÃ©alise des jointures entre les tables Ã  l'aide du mot-clÃ© JOIN  .

    On distingue les jointures internes, qui retournent des donnÃ©es uniquement s'il y a une correspondance entre les deux tables, et les jointures externes qui retournent toutes les donnÃ©es, mÃªme s'il n'y a pas de correspondance.

Si vous souhaitez en savoir plus sur les bases de donnÃ©es MySQL, je vous invite Ã  lire le  cours de Chantal Gribaumont entiÃ¨rement dÃ©diÃ© Ã  MySQL.
