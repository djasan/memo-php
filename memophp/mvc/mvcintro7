La gestion des erreurs est un sujet important en programmation. Il y a souvent des erreurs et il faut savoir vivre avec. Mais comment faire √ßa bien ? ü§î

Si vous vous souvenez de notre routeur, il contient beaucoup de if. On fait des tests et on affiche des erreurs √† chaque fois qu'il y a un probl√®me :

<?php


if (test) {

   // C'est bon, on fait des choses

   // ...


   if (encoreUnTest) {

    // C'est bon, on continue

   } else {

    echo 'Erreur';

   }

} else {

   echo 'Autre erreur';

}

Et alors, √ßa marche, non ?

Oui, mais comme toujours, ce n'est pas parce que √ßa marche que c'est pratique √† la longue. Les d√©veloppeurs ont en particulier du mal √† g√©rer comme √ßa les erreurs qui ont lieu √† l'int√©rieur des fonctions.

Que se passe-t-il s'il y a une erreur dans le contr√¥leur ou dans le mod√®le ? Va-t-on les laisser se charger d'afficher des erreurs ? √áa ne devrait normalement pas √™tre √† eux de le faire. Ils devraient remonter qu'il y a une erreur et laisser une partie sp√©cialis√©e du code traiter l'erreur.
Tirez parti des exceptions

Les exceptions sont un moyen en programmation de g√©rer les erreurs. Vous en avez peut-√™tre d√©j√† vu dans du code PHP, √ßa ressemble √† √ßa :

<?php


try {

   // Essayer de faire quelque chose

} catch (Exception $e) {

   // Si une erreur se produit, on arrive ici

}

En premier lieu, l'ordinateur essaie d'ex√©cuter les instructions qui se trouvent dans le bloc try("essayer" en anglais). Deux possibilit√©s :

    soit il ne se passe aucune erreur dans le bloc try: dans ce cas, on saute le bloc catchet on passe √† la suite du code ;

    soit une erreur se produit dans le bloc try: on arr√™te ce qu'on faisait et on va directement dans le catch(pour "attraper" l'erreur).

C'est par exemple ce qu'on fait ici pour se connecter √† la base de donn√©es :

<?php


// Code avant


try {

    $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

} catch(Exception $e) {

    die('Erreur : '.$e->getMessage());

}


// Code apr√®s

On essaie de se connecter √† la base de donn√©es dans le bloc try:

    si tout va bien, on continue (on va dans le "Code apr√®s") ;

    si, en revanche, il y a un souci lors de la connexion (√† l'int√©rieur du new PDO), alors on r√©cup√®re l'erreur dans le bloccatchet ledieest ex√©cut√©.

On peut afficher l'erreur qui nous a √©t√© envoy√©e avec $e->getMessage().

Pour g√©n√©rer une erreur, il faut "jeter une exception", ou "lancer une exception" (oui, on dit √ßa üòÇ ). D√®s qu'il y a une erreur quelque part dans votre code, dans une fonction par exemple, vous utiliserez cette ligne :

<?php

throw new Exception('Message d\'erreur √† transmettre');

On va utiliser ce m√©canisme dans notre code !

En PHP, les exceptions sont intimement li√©es √† la programmation orient√©e objet (POO). Pour l'instant, on ne va pas approfondir les d√©tails. Mais apprendre la POO vous permettra de passer √† un niveau de ma√Ætrise sup√©rieur des exceptions. Et √ßa tombe plut√¥t bien : la prochaine grande partie du cours sera d√©di√©e √† vous faire d√©couvrir ce nouveau paradigme de programmation !
Ajoutez la gestion des exceptions dans le routeur

Je vous propose d'entourer tout notre routeur par un bloctry/catchcomme ceci :

<?php

// index.php


require_once('src/controllers/add_comment.php');

require_once('src/controllers/homepage.php');

require_once('src/controllers/post.php');


try {

    if (isset($_GET['action']) && $_GET['action'] !== '') {

        if ($_GET['action'] === 'post') {

            if (isset($_GET['id']) && $_GET['id'] > 0) {

                $identifier = $_GET['id'];


                post($identifier);

            } else {

                throw new Exception('Aucun identifiant de billet envoy√©');

            }

        } elseif ($_GET['action'] === 'addComment') {

            if (isset($_GET['id']) && $_GET['id'] > 0) {

                $identifier = $_GET['id'];


                addComment($identifier, $_POST);

            } else {

                throw new Exception('Aucun identifiant de billet envoy√©');

            }

        } else {

            throw new Exception("La page que vous recherchez n'existe pas.");

        }

    } else {

        homepage();

    }

} catch (Exception $e) { // S'il y a eu une erreur, alors...

    echo 'Erreur : '.$e->getMessage();

}

Comme vous pouvez le voir, √† l'endroit o√π les erreurs se produisent j'ai mis des throw new Exception. Cela arr√™te le bloc tryet am√®ne directement l'ordinateur au bloc catch.

Ici, notre bloc catchse contente de r√©cup√©rer le message d'erreur qu'on a transmis et de l'afficher.
Remontez les exceptions

Pour l'instant, vous vous dites s√ªrement que √ßa n'est pas fou fou. Ok, les exceptions sont faites pour g√©rer les erreurs, mais on a surtout compliqu√© le code du routeur avec un nouveau bloc.

C'est parce que vous n'avez pas encore vu √† quel point les exceptions peuvent √™tre pratiques ! Quand il se passe une erreur √† l'int√©rieur d'une fonction situ√©e dans le bloc try, celle-ci est "remont√©e" jusqu'au bloc catch.

Par exemple, notre routeur appelle la fonction du contr√¥leuraddComment, on est d'accord ? Que se passe-t-il quand il y a une erreur dans le contr√¥leur ? Pour l'instant, on fait √ßa :

<?php

// src/controllers/add_comment.php


require_once('src/model/comment.php');


function addComment(string $post, array $input)

{

    $author = null;

    $comment = null;

    if (!empty($input['author']) && !empty($input['comment'])) {

        $author = $input['author'];

        $comment = $input['comment'];

    } else {

        die('Les donn√©es du formulaire sont invalides.');

    }


    $success = createComment($post, $author, $comment);

    if (!$success) {

        die('Impossible d\'ajouter le commentaire !');

    } else {

        header('Location: index.php?action=post&id=' . $post);

    }

}

Notre contr√¥leur arr√™te tout et affiche ses erreurs avec desdie. Il y a moyen de faire plus propre : jetons ici des exceptions, le code s'y arr√™tera, et les erreurs seront remont√©es jusque dans le routeur qui contenait le bloc try !

Voil√† comment on peux mieux g√©rer les erreurs, en ajoutant desthrow  :

<?php

// src/controllers/add_comment.php


require_once('src/model/comment.php');


function addComment(string $post, array $input)

{

    $author = null;

    $comment = null;

    if (!empty($input['author']) && !empty($input['comment'])) {

        $author = $input['author'];

        $comment = $input['comment'];

    } else {

        throw new Exception('Les donn√©es du formulaire sont invalides.');

    }


    $success = createComment($post, $author, $comment);

    if (!$success) {

        throw new Exception('Impossible d\'ajouter le commentaire !');

    } else {

        header('Location: index.php?action=post&id=' . $post);

    }

}

Pratique, non ? Ce principe de "remont√©e" de l'erreur jusqu'√† l'endroit du code qui contenait le bloc try  est vraiment un gros avantage des exceptions.

Comme ce n'est pas forc√©ment √©vident √† voir comme √ßa, je vous ai r√©sum√© le concept dans un sch√©ma (j'adore les sch√©mas, je vous l'ai d√©j√† dit ?) :
Lorsqu'une erreur survient dans une sous-fonction, elle est remont√©e jusqu'au bloc catch.
L'erreur remonte jusqu'au bloc catch

Du coup, dans la fonction dbConnect()de notre mod√®le, il n'est plus forc√©ment n√©cessaire de garder un bloctry/catch. L'erreur de connexion √† la base, s'il y en a une, sera remont√©e jusqu'au routeur :

<?php


function dbConnect()

{

    $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');


    return $database;

}

Pour compl√©ter mon explication, je vous propose de regarder ce screencast qui d√©taille, de mani√®re tr√®s visuelle, le fonctionnement des exceptions en PHP.
Exercez-vous

Pour l'instant, notre bloccatchaffiche une erreur avec un simpleecho. Si nous voulons faire quelque chose de plus joli, nous pouvons appeler une vuetemplates/error.phpqui affiche joliment le message d'erreur.

Il faudrait faire quelque chose dans ce go√ªt-l√† :

<?php

// index.php


require_once('src/controllers/add_comment.php');

require_once('src/controllers/homepage.php');

require_once('src/controllers/post.php');


try {

    // ...

} catch (Exception $e) {

    $errorMessage = $e->getMessage();


    require('templates/error.php');

}

Bon, l√† je vous laisse travailler la vue vous-m√™me, je pense que vous avez compris le concept !

R√©cup√©rez le zip du d√©but de ce chapitre depuis le Github. L'√©tiquette Git associ√©e au d√©but de ce chapitre estgerez-erreurs. Vous pouvez aussi retrouver le code dans votre navigateur via ce lien Github.
En r√©sum√©

    Les exceptions sont un m√©canisme qui permet de g√©rer les remont√©es d'erreurs en PHP. Elles s'utilisent avec les trois mots cl√©s :try,catchetthrow.

    tryetcatchpermettent de cr√©er des zones de contr√¥les sur les exceptions.

    throwpermet de lancer une exception. Elle interrompra le flux classique d'ex√©cution du code, jusqu'√† √™tre g√©r√©e par une zone de contr√¥le d'exception.

    Les zones de contr√¥le d'exception peuvent s'imbriquer √† l'infini.
