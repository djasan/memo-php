C'est parti pour cette nouvelle partie de cours, d√©di√©e √† la Programmation Orient√©e Objet, appliqu√©e au patron de conception MVC !

Oh non, pas la Programmation Orient√©e Objet ! √Ä ce qu'il para√Æt, c'est compliqu√©. Mon cousin Micka√´l m'a tout racont√©, ces histoires d'objets, de classes, d'h√©ritage... Est-ce qu'on est vraiment oblig√© d'en passer par l√† ?

J'ai deux choses √† vous r√©pondre. D'une part, si vous souhaitez appr√©hender la Programmation Orient√©e Objet (vous pouvez l'abr√©ger POO), je vous conseille le super cours que nos formateurs lui ont d√©di√© : Programmez en orient√© objet en PHP. Il part vraiment de z√©ro et explique toutes les notions que vous devez conna√Ætre √©tape par √©tape. Si vous avez d√©j√† quelques notions en POO, mais que vous √™tes toujours un peu f√©briles quand vous rencontrez desnew PostManager()ou des h√©ritages, alors la suite va vous plaire.

Voil√† mon second point : ce cours ne va PAS aborder la Programmation Orient√©e Objet comme une finalit√©. D√©j√†, vous pouvez consid√©rer qu'avec moi, LA POO n'existe pas. Il y a une quantit√© infinie de mani√®res d'utiliser la mod√©lisation Objet. Ici, vous allez simplement am√©liorer votre code avec les outils que vous propose PHP, le langage de programmation que vous utilisez !

Vous trouverez le zip du cours sur le Github. R√©cup√©rez le code avec l'√©tiquettestructurez-donnees, pour que nous partions de la m√™me base. Vous pouvez aussi voir les sources actuelles via l'interface Github.
Analysez les interactions entre les couches du MVC

Quand on utilise le design pattern MVC, on s√©pare notre code en trois couches : le mod√®le, la vue et le contr√¥leur. Pour chaque requ√™te HTTP venant de l'utilisateur, des morceaux de code de chacune des couches vont interagir ensemble pour r√©aliser l'ensemble du travail de g√©n√©ration de la r√©ponse. Normalement, jusque ici, vous ma√Ætrisez ! üòä

Par exemple, en ouvrant votre contr√¥leursrc/controllers/homepage.php, vous pouvez analyser les interactions entre ces couches :

<?php


require_once('src/model.php');


function homepage()

{

    $posts = getPosts();


    require('templates/homepage.php');

}

Elles sont d'ailleurs plus ou moins explicites et, par cons√©quent, plus ou moins √©videntes √† remarquer. Ici, il y en a 2 :

    √Ä la ligne 7, le r√©sultat de la fonctiongetPosts(), mise √† disposition par le mod√®le, est r√©cup√©r√© par le contr√¥leur. C'est la premi√®re interaction et elle est explicite.

    √Ä la ligne 9, l'utilisation de l'instructionrequireimplique la seconde interaction, entre le contr√¥leur et la vue. Celle-l√† est implicite, vous la voyez ? Eh oui, la variable$postsest rendue disponible √† l'usage √† l'int√©rieur du fichiertemplates/homepage.php.

Avec beaucoup de m√©moire, vous vous souvenez peut-√™tre d'une de mes d√©clarations durant ce cours : avec le MVC, le d√©veloppeur qui impl√©mente la vue n'a pas besoin de conna√Ætre le d√©tail de l'impl√©mentation du mod√®le. Il a simplement besoin de savoir comment utiliser la valeur de retour.

Pour l'instant, dans notre code, ce protocole de communication entre nos couches est d√©fini par... de la documentation orale ! Or, la documentation est sujette √† un risque majeur : sa p√©remption.
Utilisez du code pour d√©finir vos protocoles

En programmation, il y a une maxime qui dit :

    La documentation la plus pr√©cise pour une application, c'est son code source !

Et si vous pouviez produire du code qui d√©finisse lui-m√™me sa documentation ? √áa serait fantastique : plus besoin d'aller fouiller dans le code des autres pour comprendre ce qu'on peut en faire ! üòç

Les plus malins d'entre vous auront not√© que vous le faites d√©j√†, √† un certain niveau. Par exemple danssrc/model/comment.php, que voyez-vous √† la troisi√®me ligne ?

<?php


// ...

function getComments(string $post)

// ...

Le prototype de la fonctiongetCommentsindique que son premier param√®tre ($post) doit √™tre de typestring(une cha√Æne de caract√®res). Et que se passe-t-il si un d√©veloppeur essaye de passer une variable de typeint(un nombre entier) en param√®tre ? C'est directement PHP qui lui dit que c'est impossible. Puissant !

D'accord, on arrive √† le faire avec des cas simples. Mais, dans la vraie vie, les demandes de mes clients sont rarement aussi simples... Rien que pour d√©finir un commentaire sur un billet, on avait au moins 3 variables !

C'est s√ªr, il nous faut encore plus fort. Dans votre code, vous aviez repr√©sent√© vos commentaires en les composant de trois variables aux types plus simples fournis par PHP : 

    l'auteur, une cha√Æne de caract√®resstring;

    la date, une cha√Æne de caract√®resstring;

    le commentaire, encore une cha√Æne de caract√®resstring.

Et si on pouvait cr√©er notre propre type, qui serait compos√© de plusieurs sous-types ? On pourrait repr√©senter tout ce qu'on veut apr√®s ! ü§©

C'est exactement √ßa, vous comprenez vite ! Et chaque variable ayant votre type serait valid√©e par PHP, pour qu'elle contienne uniquement les √©l√©ments attendus. Je vous propose de vous lancer directement dans le code qui va d√©finir ce type en PHP :

<?php


class Comment {}

Et voil√†, vous avez d√©fini un nouveau type ! En PHP, on appelle √ßa une classe. Et chacune a un nom unique. Ici, c'est la classeComment(les noms de classes, comme tout notre code, doivent √™tre en anglais).

Ok, mais comment je fais pour cr√©er une variable avec ce type ?

<?php

 

class Comment {}

 

$comment = new Comment();

 Avec ce code, vous cr√©ez une nouvelle instance de commentaire. C'est ce qu'on appelle instancier une classe. Pour le faire en PHP, vous utilisez l'instructionnew, suivi du nom de votre classe. 

Vous avez d√©j√† rencontr√© le mot-cl√©new, vous vous souvenez ? Ouvrez votre fichiersrc/model.phpet regardez la fonctiondbConnect(): il y a$database = new PDO(), qui sert √† instancier une nouvelle connexion √† la base de donn√©es !

Cette instance s'appelle un objet (comme dans "Programmation Orient√©e Objet") et vous l'assignez dans votre variable$comment. On dit aussi que la variable$comment est de typeComment. 

Bon, pour l'instant ce commentaire ne sert pas √† grand-chose, √©tant donn√© qu'il est vide...

C'est le moment d'ajouter des propri√©t√©s √† votre classe. Ce sont les √©l√©ments qui composent votre classe. Chaque propri√©t√© aura son propre type. Pour √ßa, vous allez √©crire des nouvelles d√©finitions de propri√©t√©s, √† l'int√©rieur du bloc d'accolades qui d√©crit votre classe  :

<?php

 

class Comment

{

    public string $author;

    public string $frenchCreationDate;

    public string $comment;

}

 

$comment = new Comment();

Votre classe est d√©sormais compos√©e des trois "sous-variables" voulues :

    l'auteur ;

    la date de cr√©ation ;

    le commentaire. 

Vous avez remarqu√© le mot-cl√©public, devant chaque propri√©t√© ? Il est essentiel pour indiquer que la propri√©t√© sera visible par le code utilisant la classe. Nous n'√©tudierons pas la notion de visibilit√© dans ce cours, mais sachez qu'il y a deux autres alternatives :privateetprotected(en fran√ßais, priv√© et prot√©g√©).

En tant que d√©veloppeur, en lisant simplement le code de cette classe, vous √™tes certains de savoir ce qu'elle va contenir. Et PHP couvre vos arri√®res, en vous assurant tout le temps que c'est bien le cas. Vous avez mieux qu'une documentation : vous avez un code strict ! F√©licitations !

Je vous propose de suivre ce screencast pour revoir, ensemble, les √©tapes de la cr√©ation d'une classe, de la d√©finition de ses propri√©t√©s, et de son instanciation. C'est un sujet complexe, alors soyez s√ªr de bien le comprendre !

Attendez, attendez ! Ne me laissez pas comme √ßa, je ne sais m√™me pas comment je dois faire pour utiliser cette classe. Vous n'avez pas des informations en plus √† me donner ?

Pas d'inqui√©tude, j'y viens tout de suite. üòÅ
Utilisez votre nouveau typeComment

Les propri√©t√©s d'un objet sont accessibles via une nouvelle syntaxe : l'op√©rateur fl√®che->, suivi du nom de la propri√©t√© √† laquelle vous acc√©dez. Ainsi, pour renseigner la date de cr√©ation d'un commentaire, vous allez faire :

<?php

 

class Comment

{

    public string $author;

    public string $frenchCreationDate;

    public string $comment;

}

 

$comment = new Comment();

$comment->frenchCreationDate = '10/03/2022 √† 15h09';

Bien entendu, l'op√©rateur fl√®che fonctionne aussi pour l'acc√®s en lecture √† des propri√©t√©s. D'ailleurs, on va le voir tout de suite.

Vous allez modifier le fichiersrc/model/comment.php pour que la fonctiongetComments()construise et renvoie un tableau d'objetsComment. Je vous laisse essayer de votre c√¥t√© et on corrige ensemble ensuite !

‚Ä¶

‚Ä¶

‚Ä¶

Alors, √ßa a donn√© quelque chose ? Voyons voir le code que je vous propose :

<?php

// src/model/comment.php


class Comment

{

    public string $author;

    public string $frenchCreationDate;

    public string $comment;

}


function getComments(string $post): array

{

    $database = commentDbConnect();

    $statement = $database->prepare(

        "SELECT id, author, comment, DATE_FORMAT(comment_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM comments WHERE post_id = ? ORDER BY comment_date DESC"

    );

    $statement->execute([$post]);


    $comments = [];

    while (($row = $statement->fetch())) {

        $comment = new Comment();

        $comment->author = $row['author'];

        $comment->frenchCreationDate = $row['french_creation_date'];

        $comment->comment = $row['comment'];


        $comments[] = $comment;

    }


    return $comments;

}


// ...

On a ajout√© la d√©claration de la classeCommenten haut du fichier. Dans notre bouclewhile, pour chaque ligne de r√©sultat SQL, on a instanci√© un nouvel objet de typeComment. Enfin, on a renseign√© la valeur de chacune des propri√©t√©s.

J'en ai profit√© pour rajouter un type de retourarrayau prototype de la fonctiongetComments. √áa ne change pas grand chose, mais c'est plus strict. Vous voyez pour l'occasion qu'en PHP, il est impossible de mieux typer que √ßa un tableau d‚Äôobjets. C'est une des limites actuelles du langage, que vous continuerez √† combler par de la documentation !

Passons √† la modification du templatetemplates/post.php, qui re√ßoit maintenant des objets √† la place de tableaux index√©s :

<!-- templates/post.php -->


<?php $title = "Le blog de l'AVBN"; ?>


<?php ob_start(); ?>

<h1>Le super blog de l'AVBN !</h1>

<p><a href="index.php">Retour √† la liste des billets</a></p>


<div class="news">

    <h3>

        <?= htmlspecialchars($post['title']) ?>

        <em>le <?= $post['french_creation_date'] ?></em>

    </h3>


    <p>

        <?= nl2br(htmlspecialchars($post['content'])) ?>

    </p>

</div>


<h2>Commentaires</h2>


<form action="index.php?action=addComment&id=<?= $post['identifier'] ?>" method="post">

   <div>

    <label for="author">Auteur</label><br />

    <input type="text" id="author" name="author" />

   </div>

   <div>

    <label for="comment">Commentaire</label><br />

    <textarea id="comment" name="comment"></textarea>

   </div>

   <div>

    <input type="submit" />

   </div>

</form>


<?php

foreach ($comments as $comment) {

?>

    <p><strong><?= htmlspecialchars($comment->author) ?></strong> le <?= $comment->frenchCreationDate ?></p>

    <p><?= nl2br(htmlspecialchars($comment->comment)) ?></p>

<?php

}

?>

<?php $content = ob_get_clean(); ?>


<?php require('layout.php') ?>

Il n'y a que 2 lignes qui ont chang√©, √† l'int√©rieur duforeach. On a juste remplac√© la syntaxe d'acc√®s aux index d'un tableau ($array['index']) par celle d'acc√®s aux propri√©t√©s d'un objet ($object->property).

Je vous r√©sume cette partie dans un screencast ? C'est parti pour revoir comment utiliser un objet et ses propri√©t√©s en PHP.
Exercez-vous

Bien, on a r√©ussi √† faire √ßa ensemble pour les commentaires. Et si vous vous lanciez dans la modification des billets en suivant le m√™me sch√©ma ?

Ah et, en passant, profitez-en pour d√©placer le mod√®le des billets dans un fichier rien qu'√† lui, commesrc/model/post.php!

Vous pourrez comparer votre code √† celui du d√©p√¥t Github du d√©but du prochain chapitre et voir si vous n'avez rien oubli√©.

C'est bon, vous √™tes maintenant "programmeurs orient√©s objet", toutes mes f√©licitations. C'est parti pour le quiz ! üòÅ
En r√©sum√©

    Le patron de conception MVC utilise 3 couches de code. Les interactions entre chacune des couches doivent √™tre structur√©es et document√©es le mieux possible, pour faciliter la maintenance du code dans son ensemble.

    En cr√©ant vos propres types gr√¢ce aux classes, vous saurez exactement ce qu'ils vont faire. Le code strict est une excellente mani√®re de structurer son code. Il permet aussi √† PHP d'aider les d√©veloppeurs, en faisant des v√©rifications automatiques en amont.

    On peut cr√©er des types personnalis√©s en PHP, gr√¢ce aux classes. Chaque classe doit avoir un nom unique. Chaque classe sera compos√©e avec des propri√©t√©s ayant d'autres types (simples ou personnalis√©s).

    L'action de cr√©er des variables √† partir de ces types personnalis√©s s'appelle "instancier une classe". On appelle ces instances des "objets".

    Les propri√©t√©s d'un objet peuvent √™tre obtenues gr√¢ce √† l'op√©rateur fl√®che->. Cet op√©rateur s'utilise aussi bien pour lire la valeur d'une propri√©t√© que pour y √©crire une nouvelle valeur.
