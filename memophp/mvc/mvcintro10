Au final, on a r√©duit le nombre de connexions √† la base de donn√©es √† 1 par instance dePostRepository. C'est bien, mais on n'a pas encore atteint l'objectif qu'on s'√©tait fix√©. Par exemple, sur la page d'affichage d'un billet, on a une connexion SQL pour les billets et une autre pour les commentaires.

Comment pourriez-vous faire pour permettre l'utilisation d'une seule connexion pour les deux mod√®les ? ü§î

Je vous propose de continuer √† travailler sur notrePostRepository, dans un premier temps. Une fois qu'on aura la possibilit√© de cr√©er deux instances de cette classe, et que celles-ci partageront la m√™me connexionPDO, alors vous appliquerez les changements au code mod√®le des commentaires.

Avant de commencer √† travailler, je vous invite √† r√©cup√©rer le code source √† jour en zip depuis le Github ou avec l'√©tiquette Gittirez-parti-composition. Vous pouvez aussi les parcourir dans votre navigateur via l'interface Github.
Initiez-vous √† la composition

Commen√ßons par relire le code que nous avions danssrc/model/post.php:

<?php


class Post

{

    public string $title;

    public string $frenchCreationDate;

    public string $content;

    public string $identifier;

}


class PostRepository

{

    public ?PDO $database = null;


    public function getPost(string $identifier): Post

    {

        $this->dbConnect();

        $statement = $this->database->prepare(

            "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

        );

        $statement->execute([$identifier]);


        $row = $statement->fetch();

        $post = new Post();

        $post->title = $row['title'];

        $post->frenchCreationDate = $row['french_creation_date'];

        $post->content = $row['content'];

        $post->identifier = $row['id'];


        return $post;

    }


    public function getPosts(): array

    {

        $this->dbConnect();

        $statement = $this->database->query(

            "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts ORDER BY creation_date DESC LIMIT 0, 5"

        );

        $posts = [];

        while (($row = $statement->fetch())) {

            $post = new Post();

            $post->title = $row['title'];

            $post->frenchCreationDate = $row['french_creation_date'];

            $post->content = $row['content'];

            $post->identifier = $row['id'];


            $posts[] = $post;

        }


        return $posts;

    }


    public function dbConnect()

    {

        if ($this->database === null) {

            $this->database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

        }

    }

}

Actuellement, si je change la valeur de la propri√©t√©$databased'une instance dePostRepository, √ßa ne modifiera pas la valeur de la propri√©t√© dans mes autres instances. C'est bien normal : on veut que chaque objet soit autonome et ait son propre contexte. C'√©tait nos deux pr√©requis au chapitre pr√©c√©dent !

Oui mais, on veut quand m√™me que nos objets puissent utiliser la m√™me connexion. On ne peut pas les obliger √† avoir le m√™me contexte ?

Techniquement, c'est possible avec le mot-cl√©static. Je n'en parlerai pas ici, parce que c'est une pratique plut√¥t d√©conseill√©e. En plus, d√®s qu'on passera au mod√®le des commentaires, la probl√©matique se posera √† nouveau. Et √† ce moment-l√†, avec deux classes diff√©rentes, √ßa sera r√©ellement impossible que leurs instances partagent le m√™me contexte.

Non, ce qu'il nous faut, c'est composer avec des objets !

La composition, c'est construire √† partir d'un ou plusieurs tiers. Quand vous composez en musique, vous prenez des notes qui n'ont rien √† voir entre elles et vous les arrangez vous-m√™me les unes √† c√¥t√© des autres sur une partition. En programmation orient√©e objet, c'est pareil : vous prenez des objets qui n'ont rien √† voir entre eux et vous les arrangez vous-m√™me dans un nouvel objet.

C'est un peu d√©j√† ce qu'on fait avec notrePostRepositoryet l'objetPDO√† l'int√©rieur, non ?

Exactement, vous suivez bien ! Le gros probl√®me actuellement, c'est que nous composons avec un objet qui n'a PAS la responsabilit√© d'initialiser automatiquement la connexion.

Il nous faudrait un nouveau concept, donc une nouvelle classe. Elle repr√©senterait une connexion avec la base de donn√©es, soit active, soit pas encore initialis√©e. On appellerait √ßa... la classeDatabaseConnection!

Hum, vous n'√™tes pas all√© chercher bien loin l√†. üòë

Eh oui, mais c'est un des gros avantages de la programmation orient√©e objet face √† la programmation proc√©durale. En proc√©dural, on ne peut d√©finir que des fonctions, qui repr√©sentent des actions. En orient√© objet, on peut d√©finir des concepts, potentiellement associ√©s √† des actions. Il nous reste simplement √† les nommer de mani√®re compr√©hensible par les d√©veloppeurs : en anglais !
Cr√©ez la classeConnection

Avant de cr√©er cette classe, il faut qu'on discute rapidement d'o√π nous allons la mettre.

Ce sont bien des sources PHP, donc le dossiersrc/semble le bon endroit. Par contre, je ne vais pas faire un contr√¥leur. Ce n'est pas vraiment du mod√®le non plus, d'ailleurs. Je n'ai pas d'autres dossiers pour le moment, j'en fais quoi ? ü§î

En fait, c'est une nouvelle cat√©gorie de code. C'est du code qu'on pourrait qualifier d'outillage. Il sert √† r√©soudre des probl√©matiques purement techniques : ici, maintenir une connexion √† une base de donn√©es SQL. Pour ce projet, je vous propose de le mettre danssrc/lib/database.php:

<?php


class DatabaseConnection

{

    public ?PDO $database = null;


    public function getConnection(): PDO

    {

        if ($this->database === null) {

            $this->database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

        }


        return $this->database;

    }

}

Encore une fois, rien de nouveau :

    On cr√©e la classeDatabaseConnection, qui encapsule la connexionPDOdans la propri√©t√©$database. 

    Ensuite, on d√©finit une m√©thodegetConnection(), qui renvoie forc√©ment une instance dePDO. 

    √Ä l'int√©rieur de cette m√©thode, on initialise la connexion si elle ne l'est pas d√©j√†. Et voil√† !

Le plus fort avec cette classe, c'est que si on veut √©tablir une nouvelle connexion SQL, en parall√®le de l'ancienne, on a simplement √† instancier un nouvel objet. C'est la puissance de la composition : on est totalement en contr√¥le ! ü§©
UtilisezPostRepositoryavecDatabaseConnection

Bien, il nous reste maintenant √† utiliser cette nouvelle classeDatabaseConnection√† l'int√©rieur de la classePostRepository. Attention, √ßa va impacter l√©g√®rement nos contr√¥leurs :

<?php


require_once('src/lib/database.php');


// ...


class PostRepository

{

    public DatabaseConnection $connection;


    public function getPost(string $identifier): Post

    {

        $statement = $this->connection->getConnection()->prepare(

            "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

        );


        // ...

    }


    public function getPosts(): array

    {

        $statement = $this->connection->getConnection()->query(

            "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts ORDER BY creation_date DESC LIMIT 0, 5"

        );


        // ...

    }

}

J'esp√®re que vous aviez bien pens√© √† inclure le nouveau fichiersrc/lib/database.php. Pour le reste, il n'y a que 3 lignes qui changent :

    public DatabaseConnection $connection: on remplace la propri√©t√©$databasepar la propri√©t√©$connectionde typeDatabaseConnection;

    $statement = $this->connection->getConnection()->prepare(: on remplace l'acc√®s √† la propri√©t√©$databasepar l'appel de la m√©thodegetConnection()de la propri√©t√©$connection;

    $statement = $this->connection->getConnection()->query(: on fait exactement la m√™me chose !

Voici le contenu de nos contr√¥leurssrc/controllers/homepage.phpetsrc/controllers/post.phplorsqu'ils utilisent la nouvelle forme de la classePostRepository:

<?php

// src/controllers/homepage.php


require_once('src/lib/database.php');

require_once('src/model/post.php');


function homepage()

{

    $postRepository = new PostRepository();

    $postRepository->connection = new DatabaseConnection();

    $posts = $postRepository->getPosts();


    require('templates/homepage.php');

}

<?php

// src/controllers/post.php


require_once('src/lib/database.php');

require_once('src/model/comment.php');

require_once('src/model/post.php');


function post(string $identifier)

{

    $postRepository = new PostRepository();

    $postRepository->connection = new DatabaseConnection();

    $post = $postRepository->getPost($identifier);

    $comments = getComments($identifier);


    require('templates/post.php');

}

Vous commencez √† voir que quand on modifie du code, c'est de plus en plus des changements de nom de variable, des acc√®s √† d'autres propri√©t√©s... C'est un des gros avantages de la POO : il y a un aspect jeu de briques, qu'on empile, d√©pile et r√©-empile, pour que notre application prenne la forme qu'on souhaite. Finalement, il n'y a que lorsqu'il nous manque un mod√®le de brique qu'on doit la coder !
R√©capitulons en vid√©o

Entre la cr√©ation de la nouvelle classeDatabaseConnection, l'am√©lioration du mod√®le des billets et la mise √† jour des contr√¥leurs utilisant tout √ßa... C'est beaucoup de changements pour ce chapitre, finalement. Je vais reprendre les modifications importantes dans ce screencast, n'h√©sitez pas √† le suivre !
Exercez-vous

On a utilis√© ensemble la composition d'objets pour permettre √† deux instances diff√©rentes dePostRepositoryd'utiliser la m√™me connexionPDO, et c'√©tait le point difficile.

C'est maintenant √† votre tour de refactoriser le mod√®le des commentaires, pour qu'il utilise la nouvelle classeDatabaseConnection. Une fois que vous aurez r√©ussi, il n'y aura plus qu'une seule connexion au serveur SQL dans votre contr√¥leursrc/controllers/post.php. Et n'oubliez pas la fonctionnalit√© d'ajout de commentaire ! üòÅ

Rendez-vous au prochain chapitre pour comparer votre code avec celui du d√©p√¥t Github !
En r√©sum√©

    La composition en programmation orient√©e objet, c'est utiliser des objets comme propri√©t√©s √† l'int√©rieur d'autres classes.

    La composition, quand elle est utilis√©e entre objets poss√©dant des m√©thodes, permet de d√©l√©guer des responsabilit√©s de la classe compos√©e vers la classe composante.

    La composition permet de rester en contr√¥le permanent de son code. Elle permet de facilement re-responsabiliser n'importe quelle partie du code, √† n'importe quel moment.
