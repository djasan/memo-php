La premi√®re bonne pratique que nous devons prendre consiste √† √©viter de m√©langer l'affichage du reste.

√áa veut dire qu'on va s√©parer le code HTML du code PHP ?

Oui, en gros. Mais vous allez voir que ce n'est pas aussi simple que √ßa. üòâ
Faites une premi√®re s√©paration

Commen√ßons par s√©parer le code en deux sections :

    On r√©cup√®re les donn√©es. C'est l√† qu'on fait notamment la requ√™te SQL. Vous voyez aussi qu'on cr√©e une variable structur√©e, appel√©e$posts, qui contient les "donn√©es brutes" utiles √† l'affichage de chaque billet de blog. Je vous recommande d'utiliser uniquement des types PHP simples pour ces variables : tableaux, cha√Ænes de caract√®res, nombres entiers...

    On affiche les donn√©es en les formatant. Notez qu'on utilise uniquement ces fameuses "donn√©es brutes" en provenance de la premi√®re section. √âtant donn√© qu'on dispose de variables de types simples, il est assez facile de les formater comme on le souhaite (avec les fonctions nl2br()et htmlspecialchars(), par exemple).

C'est relativement simple √† faire :

<?php


// We connect to the database.

try {

    $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

} catch(Exception $e) {

    die('Erreur : '.$e->getMessage());

}


// We retrieve the 5 last blog posts.

$statement = $database->query(

    "SELECT id, titre, contenu, DATE_FORMAT(date_creation, '%d/%m/%Y √† %Hh%imin%ss') AS date_creation_fr FROM billets ORDER BY date_creation DESC LIMIT 0, 5"

);

$posts = [];

while (($row = $statement->fetch())) {

    $post = [

        'title' => $row['titre'],

        'french_creation_date' => $row['date_creation_fr'],

        'content' => $row['contenu'],

    ];


    $posts[] = $post;

}


?>


<!DOCTYPE html>

<html>

    <head>

        <meta charset="utf-8" />

        <title>Le blog de l'AVBN</title>

        <link href="style.css" rel="stylesheet" />

    </head>


    <body>

        <h1>Le super blog de l'AVBN !</h1>

        <p>Derniers billets du blog :</p>


        <?php

        foreach ($posts as $post) {

        ?>

            <div class="news">

                <h3>

                    <?php echo htmlspecialchars($post['title']); ?>

                    <em>le <?php echo $post['french_creation_date']; ?></em>

                </h3>

                <p>

                    <?php

                    // We display the post content.

                    echo nl2br(htmlspecialchars($post['content']));

                    ?>

                    <br />

                    <em><a href="#">Commentaires</a></em>

                </p>

            </div>

        <?php

        } // The end of the posts loop.

        ?>

    </body>

</html>

Dans le premier chapitre, je vous disais qu'√©crire du code professionnel, c'√©tait notamment √©crire du code en anglais et respecter une norme de formatage. Alors commencez directement √† prendre de bonnes habitudes en corrigeant tout ce qui ne convient pas !

Gr√¢ce √† cette s√©paration, on sait plus facilement rep√©rer la section qui s'occupe de r√©cup√©rer les donn√©es de celle qui les affiche. C'est assez dense, hein ? Je vous propose de suivre ce screencast qui reprend chacune de nos modifications, pas √† pas :

Bon, c'est d√©j√† bien mieux, mais ce n'est encore qu'un d√©but. On peut aller plus loin et d√©couper √ßa en 2 fichiers distincts. Allons-y.
S√©parez le code en 2 fichiers

Ici, je vous propose de faire 2 fichiers :

    index.php (il y a toujours un  index.php  , c'est le fichier de base de votre site lu en premier) : il s'occupera de r√©cup√©rer les donn√©es et d'appeler l'affichage.

    templates/homepage.php  : il affichera les donn√©es dans la page.

On cr√©e un dossier qui contient seulement les gabarits d'affichage (les templates, en anglais) de chacune des pages du blog. Ils sont s√©par√©s du code responsable d'agir sur les donn√©es. Vous verrez plus tard dans votre apprentissage sur les frameworks (Symfony ou Laravel, par exemple), que c'est une pratique tr√®s souvent utilis√©e. Vous saurez que √ßa aide votre code √† √™tre plus maintenable et que √ßa favorise le travail en √©quipe !

Commen√ßons !
index.php

<?php


// We connect to the database.

try {

    $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

} catch(Exception $e) {

    die('Erreur : '.$e->getMessage());

}


// We retrieve the 5 last blog posts.

$statement = $database->query(

    "SELECT id, titre, contenu, DATE_FORMAT(date_creation, '%d/%m/%Y √† %Hh%imin%ss') AS date_creation_fr FROM billets ORDER BY date_creation DESC LIMIT 0, 5"

);

$posts = [];

while (($row = $statement->fetch())) {

    $post = [

        'title' => $row['titre'],

        'french_creation_date' => $row['date_creation_fr'],

        'content' => $row['contenu'],

    ];


    $posts[] = $post;

}


require('templates/homepage.php');

?>

 Le code se contente d'appeler √† la fin le fichier templates/homepage.php.

La fonction require  marche comme un include. Il y a une seule diff√©rence : si le fichier n'est pas trouv√© quand on utilise , le script s'arr√™te et plante. C'est volontaire de ma part : la page ne doit pas s'afficher si on n'arrive pas √† charger le fichier qui contient l'affichage.

√áa aurait aussi bien march√© avec un include, mais c'est plus "propre" d'utiliser un require  dans ce cas, parce qu'il vaut mieux faire planter le script si le fichier n'√©tait pas trouv√©.
templates/homepage.php

<!DOCTYPE html>

<html>

    <head>

        <meta charset="utf-8" />

        <title>Le blog de l'AVBN</title>

        <link href="style.css" rel="stylesheet" />

    </head>


    <body>

        <h1>Le super blog de l'AVBN !</h1>

        <p>Derniers billets du blog :</p>


        <?php

        foreach ($posts as $post) {

        ?>

            <div class="news">

                <h3>

                    <?php echo htmlspecialchars($post['title']); ?>

                    <em>le <?php echo $post['french_creation_date']; ?></em>

                </h3>

                <p>

                    <?php

                    // We display the post content.

                    echo nl2br(htmlspecialchars($post['content']));

                    ?>

                    <br />

                    <em><a href="#">Commentaires</a></em>

                </p>

            </div>

        <?php

        } // The end of the posts loop.

        ?>

    </body>

</html>

Le fichier de l'affichage fonctionne comme avant. Quand il est charg√©, la variable $posts lui est automatiquement transmise par  index.php  gr√¢ce au  require  . Il ne lui reste plus qu'√† afficher les informations.

Je ne comprends pas. Je pensais que le fichier de l'affichage ne contiendrait que du HTML... mais il m√©lange en r√©alit√© du PHP et du HTML ! En quoi est-ce que c'est mieux ?

En fait, on n'a pas vraiment le choix. On est bien oblig√© de faire de temps en temps des  echo  pour afficher le contenu des variables.

Ce qui compte, c'est que le r√¥le de ce code soit uniquement d'afficher des informations. On n'y fait pas des op√©rations ou des calculs complexes, on n'y fait pas des requ√™tes en base de donn√©es.

Encore une fois, si vous souhaitez √™tre s√ªr de n'avoir rien rat√©, je vous invite √† suivre ce screencast. Il reprend tous les changements qu'on a pu apporter dans cette seconde section.
Exercez-vous

Testez ce code ! Il doit fonctionner comme avant, v√©rifiez.

Nous faisons ici ce qu'on appelle de la refactorisation. On change l'organisation du code, sans ajouter de nouvelles fonctionnalit√©s. Le but est d'avoir un code plus facile √† modifier par la suite.

Vous trouverez depuis le Github le zip contenant le code du d√©but de chapitre.

Pour les adeptes de Git, vous pouvez travailler √† partir de l'√©tiquette  isolez-affichage-traitement-php et essayer d'apporter toutes ces modifications par vous-m√™me. Vous pouvez aussi voir le code dans l'√©tat o√π il √©tait au d√©but de ce chapitre directement sur l'interface Github.
En r√©sum√©

    Une premi√®re √©tape pour rendre son code professionnel est d'isoler la partie du code responsable de g√©n√©rer l'affichage pour l'utilisateur.

    Les variables fournies aux templates doivent √™tre le plus simple possible, pour rendre plus facile le travail sur l'interface utilisateur.

    Les gabarits d'affichage peuvent contenir du code ‚Äì et c'est d'ailleurs ce qui fait toute leur puissance ‚Äì mais celui-ci n'a pour r√¥le que d'afficher des informations.
