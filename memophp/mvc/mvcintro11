Alors, vous avez r√©ussi √† correctement composer avec vos classes ? Le zip du code est t√©l√©chargeable sur le Github. L'√©tiquette Git pour acc√©der au code estutilisez-namespace  . Et voici l'√©tiquette Github.

Dans notre grand combat pour la propret√© du code, nous pouvons aller plus loin (spoiler : nous pouvons toujours aller plus loin). Il va bien falloir s'arr√™ter quelque part, et on s'approche du but que je m'√©tais fix√© : vous aider √† structurer votre code en MVC.

Il y a quand m√™me un nouveau concept que j'aimerais vous pr√©senter...
D√©couvrez le r√¥le des namespaces

De quoi va-t-on parler aujourd'hui ? Des espaces de nom (namespaces). Leur r√¥le ? √âviter les collisions de noms de classes.

Imaginez. Vous travaillez sur un gros programme. Vous r√©utilisez plusieurs biblioth√®ques. Vous pouvez √™tre s√ªr qu'√† un moment donn√©, il va bien y avoir quelqu'un qui a eu l'id√©e saugrenue de cr√©er une classe CommentRepositoryouPostRepositorytout comme vous ! √Ä ce moment-l√†, c'est le plantage garanti : on n'a pas le droit d'appeler deux classes par le m√™me nom‚Ä¶

‚Ä¶ sauf si on utilise les namespaces bien s√ªr ! Ils agissent un peu comme des dossiers. Ils vous permettent d'avoir 2 classes du m√™me nom dans votre programme, du moment qu'elles sont dans des namespaces diff√©rents.
Mettez en place votre premier namespace

Concr√®tement, les namespaces ont cette forme :

Entreprise\Projet\Section

Ce sont vraiment comme des dossiers. D'ailleurs, il est recommand√© d'utiliser l'arborescence des dossiers pour construire celle de l'espace de nom. Vous pouvez en imbriquer autant que vous voulez :

Entreprise\Projet\Section\SousSection\SousSousSection

Dans la pratique, il y a deux cas principaux pour choisir la racine de son espace de nom :

    Soit vous codez une biblioth√®que √† r√©utiliser, et vous commencerez par le nom de l'entreprise qui est responsable du projet, suivi du nom du projet. Utilisez votre nom ou votre pseudonyme, si vous n'avez pas d'entreprise.

    Soit vous codez une application finale, dont le code ne sera pas partag√©. Dans ce cas, il est plut√¥t recommand√© d'utiliser le nom g√©n√©rique `Application` (ou `App`) comme racine de vos espaces de nom. Avec notre blog, nous sommes dans cette seconde cat√©gorie.

Pour d√©finir un namespace, rien de plus simple. On va d√©clarer unnamespacejuste avant la d√©finition de la classe :

<?php


namespace Application\Model\Post;


require_once('src/lib/database.php');


// ...


class PostRepository

{

    public \DatabaseConnection $connection;


    // ...

}

Cela a un impact : les noms complets de toutes les classes et fonctions d√©clar√©es dans ce fichier sont d√©sormais diff√©rents ! Ils sont le r√©sultat de la concat√©nation de l'espace de nom avec leur nom interne.

√áa veut dire que je vais devoir repasser sur tous mes fichiers pour renseigner le nouveau nom ?

Exactement ! Tous les fichiers qui font appel aux classes de ce fichier doivent maintenant ajouter le namespace en pr√©fixe. Voil√† par exemple √† quoi va ressembler votre contr√¥leursrc/controllers/post.php:

<?php


require_once('src/lib/database.php');

require_once('src/model/comment.php');

require_once('src/model/post.php');


function post(string $identifier)

{

    $connection = new DatabaseConnection();


    $postRepository = new \Application\Model\Post\PostRepository();

    $postRepository->connection = $connection;

    $post = $postRepository->getPost($identifier);


    $commentRepository = new CommentRepository();

    $commentRepository->connection = $connection;

    $comments = $commentRepository->getComments($identifier);


    require('templates/post.php');

}

Attention : en pla√ßant le contenu du fichier  src/model/post.php  dans notre namespace, nous allons avoir un probl√®me pour appeler  DatabaseConnection  . En effet,  DatabaseConnection  est une classe qui se trouve √† la racine (dans le namespace global). Pour r√©gler le probl√®me, il faudra √©crire  \DatabaseConnection  (ligne 11) :

<?php


namespace Application\Model\Post;


require_once('src/lib/database.php');


// ...


class PostRepository

{

    public \DatabaseConnection $connection;


    // ...

}

 Par contre, la mani√®re de pointer vers la classePost, d√©finie dans le m√™me espace de nom, ne change pas. Pensez aux fichiers et aux dossiers : quand vous √™tes dans un dossier, pour pointer vers un fichier dans celui-ci, vous utilisez simplement son nom, pas de pr√©fixe !
√âvitez la r√©p√©tition du pr√©fixe

Hum, √ßa me para√Æt quand m√™me plus long √† √©crire tout √ßa. N'y a-t-il pas moyen d'√©viter de r√©p√©ter le namespace en pr√©fixe √† chaque fois ?

Oui, c'est possible. Il faut utiliser le mot-cl√© useen d√©but d'un fichier qui fait r√©guli√®rement appel √† des classes d'un m√™me namespace :

<?php


require_once('src/lib/database.php');

require_once('src/model/comment.php');

require_once('src/model/post.php');


use Application\Model\Post\PostRepository;


function post(string $identifier)

{

    $connection = new DatabaseConnection();


    $postRepository = new PostRepository();

    $postRepository->connection = $connection;

    $post = $postRepository->getPost($identifier);


    $commentRepository = new CommentRepository();

    $commentRepository->connection = $connection;

    $comments = $commentRepository->getComments($identifier);


    require('templates/post.php');

}

D'ailleurs, la plupart du code que vous pourrez croiser dans le milieu professionnel utilise toujours cesuse. C'est une mani√®re de construire un index des d√©pendances de votre fichier.

Il existe un compl√©ment au mot-cl√©use, avec le mot-cl√©as. Il sert √† d√©finir un nom personnalis√©. Par exemple, vous pouvez vous en servir pour appeler votrePostRepositorypar son pr√©nom :

<?php

 

use Application\Model\Post\PostRepository as John;

 

$postRepository = new John();

Vous n'en aurez pas souvent besoin, mais l'usage de certaines biblioth√®ques de code implique de le conna√Ætre. üòõ
R√©capitulons en vid√©o

Je vous propose de refaire un tour de cette notion d'espace de nom en suivant ce screencast. J'y reprends pas √† pas la d√©claration d'un namespace pour un fichier, les changements que √ßa implique pour les autres fichiers et l'utilisation du mot-cl√©use.
Exercez-vous

L'exercice pour ce chapitre sera simple √† expliquer : mettez tout le code situ√© dans le dossiersrc/dans des espaces de noms ! √áa va faire beaucoup de petites modifications et vous devrez v√©rifier que toutes les fonctionnalit√©s de votre blog restent fonctionnelles.

Pour le code de vos contr√¥leurs, vous avez le choix : refactoriser vos contr√¥leurs en objets ou les laisser en fonctions. Je vous recommande la premi√®re option. Cependant, si vous prenez la seconde, sachez que le mot-cl√©use functionexiste. üòÅ

Comme √† notre habitude, vous pourrez comparer votre code au r√©sultat que j'attends, gr√¢ce √† l'√©tiquette Git que je vous passerai au d√©but du prochain chapitre. Bon courage !
En r√©sum√©

    Un espace de nom, ou namespace, est un "dossier virtuel" dans lequel ranger : des classes, des fonctions et d'autres espaces de nom. Il se renseigne en haut du fichier, avant toute d√©claration de classe ou de fonction, avec le mot-cl√©namespace.

    Une arborescence d'espaces de nom permet de segmenter ses classes et fonctions de la m√™me fa√ßon qu'une arborescence de dossiers permet de segmenter ses fichiers.

    Une fois qu'une classe ou fonction est rang√©e dans un espace de nom, on doit y acc√©der par son chemin complet par le code situ√© dans un autre espace de nom. Le code situ√© dans le m√™me espace de nom peut toujours utiliser les noms sans le pr√©fixe.

    Le mot-cl√©usepeut √™tre utilis√© pour pr√©-d√©finir un nom au sein d'un fichier. Le cas le plus habituel est de s'en servir pour enlever le pr√©fixe.
