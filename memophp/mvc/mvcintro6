Bon, reprenons un peu la pratique. Cette fois, on a pour mission de permettre aux lecteurs d'ajouter des commentaires sur les billets. Que faut-il faire ?

Vous devriez commencer √† avoir l'habitude. Ce sera une bonne occasion de pratiquer ! On va faire les choses dans cet ordre :

    Modifier la vue, pour afficher le formulaire. Il a deux champs : l'auteur et le commentaire.

    √âcrire le nouveau contr√¥leur, qui traite les donn√©es envoy√©es via le formulaire.

    Mettre √† jour le routeur, pour envoyer vers le bon contr√¥leur.

    √âcrire le mod√®le. √Ä chaque commentaire ajout√©, sa date de cr√©ation est sauvegard√©e en base automatiquement. On va aussi en profiter pour refactoriser le mod√®le selon le m√©tier. üòÅ

Voyons voir comment √ßa se passe en pratique !

C'est un tr√®s bon moment pour vous exercer. R√©cup√©rez le zip du code depuis le Github, l'√©tiquette Git `ajoutez-commentaires`, ou prenez le code depuis l'interface Github, et essayez d'avancer avant de regarder chaque partie du cours.
Mettez √† jour la vue

Il faut commencer par modifier un peu la vue qui affiche un billet et ses commentaires (templates/post.php). En effet, nous devons ajouter le formulaire pour pouvoir envoyer des commentaires ! 

<!-- templates/post.php:18 -->


<!-- ... -->

<h2>Commentaires</h2>


<form action="index.php?action=addComment&id=<?= $post['identifier'] ?>" method="post">

   <div>

    <label for="author">Auteur</label><br />

    <input type="text" id="author" name="author" />

   </div>

   <div>

    <label for="comment">Commentaire</label><br />

    <textarea id="comment" name="comment"></textarea>

   </div>

   <div>

    <input type="submit" />

   </div>

</form>

<!-- ... -->

Rien de sp√©cial, c'est un formulaire quoi. üòÖ

Il faut juste bien √©crire l'URL vers laquelle le formulaire est cens√© envoyer. Ici, vous voyez que j'envoie vers une actionaddComment. Il faudra bien penser √† mettre √† jour le routage.

Vous voyez aussi qu'on a besoin de$post['identifier']que nous n'avions pas r√©cup√©r√© jusque l√†. On va modifier notre mod√®le, √† la ligne 31, pour aller la chercher depuis la base de donn√©es :

<?php

// src/model.php:31


// ...

$post = [

    'title' => $row['title'],

    'french_creation_date' => $row['french_creation_date'],

    'content' => $row['content'],

    'identifier' => $row['id'],

];

// ...

√âcrivez le contr√¥leur

L'√©criture de notre nouveau contr√¥leur va √™tre un peu plus cons√©quente. Le contr√¥leur va contr√¥ler les donn√©es soumises par l'utilisateur via le formulaire. C'est un travail rigoureux : on peut par exemple vouloir v√©rifier le nombre de caract√®res dans le commentaire ou bien si le nom de l'auteur ne contient pas de caract√®res invalides. Ici on fera une version qui contient le strict minimum.

Le contr√¥leur va prendre en param√®tres les deux entr√©es utilisateur :

    L'identifiant du billet auquel le commentaire doit √™tre associ√©. Ce sera une cha√Æne de caract√®res.

    Les donn√©es soumises par le formulaire, sous la forme d'un tableau associatif de cha√Ænes de caract√®res. √áa sera pratique, car c'est le format que PHP utilise dans la super variable$_POST!

 Allons-y, cr√©ons ce nouveau fichiersrc/controllers/add_comment.php:

<?php

// src/controllers/add_comment.php


require_once('src/model/comment.php');


function addComment(string $post, array $input)

{

    $author = null;

    $comment = null;

    if (!empty($input['author']) && !empty($input['comment'])) {

        $author = $input['author'];

        $comment = $input['comment'];

    } else {

        die('Les donn√©es du formulaire sont invalides.');

    }


    $success = createComment($post, $author, $comment);

    if (!$success) {

        die('Impossible d\'ajouter le commentaire !');

    } else {

        header('Location: index.php?action=post&id=' . $post);

    }

}

 Vous noterez qu'on teste le r√©sultat renvoy√© par notre mod√®le. √âcrire en base de donn√©es est une op√©ration qui peut √©chouer, alors on demandera √† notre mod√®le de renvoyertrueen cas de succ√®s oufalseen cas d'√©chec. Pour r√©sumer : on teste s'il y a eu une erreur et on arr√™te tout (avec undie) si jamais il y a un souci.

Si tout va bien, il n'y a aucune page √† afficher. Les donn√©es ont √©t√© ins√©r√©es, on redirige donc le visiteur vers la page du billet pour qu'il puisse voir son beau commentaire qui vient d'√™tre ins√©r√© ! üòç
Mettez √† jour le routeur

Il faut maintenant qu'on enregistre notre contr√¥leur au niveau de notre routeur. Ajoutons unelseifdans notre routeur (index.php) pour appeler le nouveau contr√¥leuraddCommentqu'on vient de cr√©er et on devrait avoir tout bon !

<?php

// index.php


require_once('src/controllers/add_comment.php');

require_once('src/controllers/homepage.php');

require_once('src/controllers/post.php');


if (isset($_GET['action']) && $_GET['action'] !== '') {

    if ($_GET['action'] === 'post') {

        if (isset($_GET['id']) && $_GET['id'] > 0) {

            $identifier = $_GET['id'];


            post($identifier);

        } else {

            echo 'Erreur : aucun identifiant de billet envoy√©';


            die;

        }

    } elseif ($_GET['action'] === 'addComment') {

        if (isset($_GET['id']) && $_GET['id'] > 0) {

            $identifier = $_GET['id'];


            addComment($identifier, $_POST);

        } else {

            echo 'Erreur : aucun identifiant de billet envoy√©';


            die;

        }

    } else {

        echo "Erreur 404 : la page que vous recherchez n'existe pas.";

    }

} else {

    homepage();

}

Ouah ! Il devient dur √† lire ce routeur, non ?

 C'est vrai qu'avec tous cesifimbriqu√©s, √ßa commence √† faire beaucoup... Mais il n'y a pas trop le choix. Ceci dit, il y a une meilleure fa√ßon de g√©rer les erreurs, on va en reparler dans un prochain chapitre. üòâ

Comme vous pouvez le voir, je teste si on a bien un ID de billet. Si c'est le cas, j'appelle le contr√¥leuraddComment, qui appelle le mod√®le pour enregistrer les informations en base. Pour la validation des champs du formulaire, on a donn√© cette responsabilit√© au contr√¥leur, alors on lui passe la variable$_POSTdirectement ! Ah, c'est beau quand tout est bien organis√© ! üòÑ

Quand vous commencerez √† utiliser des frameworks, vous verrez que les routeurs sont vraiment tr√®s puissants. Ils permettent de ne presque pas √©crire de code, tout en faisant quand m√™me ces v√©rifications. Notre routeur n'en est pas encore l√†, mais ce ne serait qu'une question de temps si on voulait l'am√©liorer !
√âcrivez le mod√®le

On y est presque ! Il nous reste √† cr√©er notre nouveau fichier mod√®le. Je vous propose qu'on segmente autour de la notion de "commentaire" sur les billets. On va donc cr√©er un nouveau fichiersrc/model/comment.php, o√π vous allez mettre la nouvelle fonctioncreateComment(). On va aussi en profiter pour y d√©placer la fonctiongetComments():

<?php

// src/model/comment.php


function getComments(string $post)

{

    $database = commentDbConnect();

    $statement = $database->prepare(

        "SELECT id, author, comment, DATE_FORMAT(comment_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM comments WHERE post_id = ? ORDER BY comment_date DESC"

    );

    $statement->execute([$post]);


    $comments = [];

    while (($row = $statement->fetch())) {

        $comment = [

            'author' => $row['author'],

            'french_creation_date' => $row['french_creation_date'],

            'comment' => $row['comment'],

        ];


        $comments[] = $comment;

    }


    return $comments;

}


function createComment(string $post, string $author, string $comment)

{

    $database = commentDbConnect();

    $statement = $database->prepare(

        'INSERT INTO comments(post_id, author, comment, comment_date) VALUES(?, ?, ?, NOW())'

    );

    $affectedLines = $statement->execute([$post, $author, $comment]);


    return ($affectedLines > 0);

}


function commentDbConnect()

{

    try {

        $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');


        return $database;

    } catch(Exception $e) {

        die('Erreur : '.$e->getMessage());

    }

}

Rien de bien sorcier. Il faut juste penser √† r√©cup√©rer en param√®tres les informations dont on a besoin :

    l'ID du billet auquel se rapporte le commentaire ;

    le nom de l'auteur ;

    le contenu du commentaire.

Le reste des informations (l'ID du commentaire, la date) sera g√©n√©r√© automatiquement.

Au fait, nous avons refactoris√© la mani√®re de r√©cup√©rer nos commentaires, mais nous n'avons pas encore mis √† jour le contr√¥leursrc/controllers/post.php. Il faut qu'on ajoute unrequire_once:

<?php

// src/controllers/post.php


require_once('src/model.php');

require_once('src/model/comment.php');


function post(string $identifier)

{

    $post = getPost($identifier);

    $comments = getComments($identifier);


    require('templates/post.php');

}

Hum, j'ai deux questions qui me chagrinent. D√©j√†, vous laissez les fichierssrc/model.phpetsrc/model/comment.php, √ßa ne vous pose pas de probl√®me ? Ensuite, on a dupliqu√© la fonctiondbConnect(), ce n'est pas id√©al, non ?

Tout d'abord, le premier point. Je suis d'accord avec vous, ce n'est pas ce que je trouve de plus beau. Cependant, quand on travaille sur un projet, on doit en permanence faire des concessions. Ici, je ne touche pas aux billets de blog. D'ailleurs, la plupart du temps, je ne me souviendrais sans doute plus de comment ce code fonctionne.

Je fais donc le choix de construire √† c√¥t√© de l'existant. Quand on souhaitera refactoriser notre gestion des billets de blog, on le fera dans un autre commit. C'est une des grandes forces de la segmentation m√©tier du code ! üòÅ

Pour le second point, c'est un peu plus complexe. D'une part, l'unit√© de code "Comment" est diff√©rente de l'unit√© de code "Post". Ce qui affecte l'un ne doit pas forc√©ment affecter l'autre. Ici, on peut consid√©rer comme une co√Øncidence que la base de donn√©es utilis√©e soit la m√™me entre ces deux bouts de code : par exemple, on pourrait tr√®s bien stocker nos commentaires via une API sp√©cialis√©e.

Cela √©tant dit, toute la partie configuration (nom de la base, mot de passe) est ici dupliqu√©e. Et √ßa, ce n'est pas une question de co√Øncidence. C'est une faiblesse dans notre code. Mais c'est une faiblesse qu'on r√©soudra beaucoup plus facilement quand on ma√Ætrisera la programmation orient√©e objet et tous les outils qu'elle nous apportera. J'ai h√¢te !
R√©capitulons en vid√©o

Ajouter une fonctionnalit√© enti√®re, c'est √©norm√©ment de modifications √† plein d'endroits du code. Si vous n'√™tes pas certain d'avoir tout suivi, voici un screencast qui reprend l'ensemble des modifications apport√©es parmi tous les fichiers.
En r√©sum√©

    Notre blog a maintenant une nouvelle fonctionnalit√© : permettre √† l'utilisateur d'ajouter des commentaires aux billets.

    Une segmentation m√©tier du code est maintenant mise en place. La notion de "commentaire" est bien isol√©e et plus facile √† retrouver.
