√áa y est, on vient de vous demander une nouvelle fonctionnalit√© ! On aimerait pouvoir afficher une page avec les commentaires de chaque billet.

Vous vous souvenez du lien "Commentaires" sous chaque billet ?
Les liens Commentaires en bas des postes du blog ne fonctionnent pas.
Il est temps de faire marcher ce lien "Commentaires" !

Lorsqu'on clique dessus, on va afficher une page avec le billet et sa liste de commentaires.

Hum, mais comment s'y prendre avec une architecture MVC ? ü§î

Je vous propose le plan suivant pour arriver √† vos fins :

    Vous commencez par √©crire la vue. Apr√®s tout, votre objectif principal reste d'afficher la page des commentaires √† l'utilisateur !

    Ensuite, vous allez √©crire un contr√¥leur, mais en version tr√®s rapide, qui fera passer des fausses donn√©es √† la vue. √áa vous permettra de v√©rifier que votre affichage correspond √† vos attentes.

    Vous affinerez le contr√¥leur en le rendant dynamique et en commen√ßant √† imaginer les services que vous souhaiteriez demander √† votre mod√®le.

    Vous finirez en impl√©mentant votre mod√®le, pour qu'il r√©ponde correctement aux demandes de votre contr√¥leur.

Ce n'est pas la seule mani√®re de faire, mais avec celle-l√† on rentre dans le lard du probl√®me par le c√¥t√© concret. C'est ma m√©thode pr√©f√©r√©e ! üòä

Vous pouvez r√©cup√©rer une base de travail :

    en t√©l√©chargeant le zip sur le Github ;

    en utilisant l'√©tiquette Gitaffichez-commentaires;

    ou en suivant ce lien Github. 

Si vous √™tes confiant, lancez-vous ! Et revenez comparer votre code au cours quand vous aurez termin√© !
Cr√©ez la vue

Qui dit nouvelle vue, dit nouveau fichier dans notre dossiertemplates/. On veut afficher un article de blog, alors nous pouvons l'appelertemplates/post.php.

<!DOCTYPE html>

<html>

    <head>

        <meta charset="utf-8" />

        <title>Le blog de l'AVBN</title>

        <link href="style.css" rel="stylesheet" />

    </head>

 

    <body>

        <h1>Le super blog de l'AVBN !</h1>

        <p><a href="index.php">Retour √† la liste des billets</a></p>


        <div class="news">

            <h3>

                <?= htmlspecialchars($post['title']) ?>

                <em>le <?= $post['french_creation_date'] ?></em>

            </h3>

 

            <p>

                <?= nl2br(htmlspecialchars($post['content'])) ?>

            </p>

        </div>

 

        <h2>Commentaires</h2>

 

        <?php

        foreach ($comments as $comment) {

        ?>

        <p><strong><?= htmlspecialchars($comment['author']) ?></strong> le <?= $comment['french_creation_date'] ?></p>

        <p><?= nl2br(htmlspecialchars($comment['comment'])) ?></p>

        <?php

        }

        ?>

    </body>

</html>

Dans cette vue, on affiche :

    le billet : on utilise une variable tableau$post, avec les indextitle,french_creation_dateetcontent;

    les commentaires : un tableau de tableaux, avec les indexauthor,french_creation_dateetcomment. 

Pour l'instant, on ne peut pas encore tester notre code HTML. Il nous faut un contr√¥leur !
Cr√©ez le contr√¥leur "simplet"

Nous avions d√©j√† √©crit un contr√¥leurindex.phppour g√©rer la liste des derniers billets. Je vous propose d'√©crire un autre contr√¥leurpost.phpqui affiche un post et ses commentaires.

<?php

 

$post = [

    'title' => 'Un faux titre.',

    'french_creation_date' => '03/03/2022 √† 12h14min42s',

    'content' => "Le faux contenu de mon billet.\nC'est fantastique !",

];

$comments = [

    [

        'author' => 'Un premier faux auteur',

        'french_creation_date' => '03/03/2022 √† 12h15min42s',

        'comment' => 'Un faux commentaire.\n Le premier.',

    ],

    [

        'author' => 'Un second faux auteur',

        'french_creation_date' => '03/03/2022 √† 12h16min42s',

        'comment' => 'Un faux commentaire.\n Le second.',

    ],

];

 

require('templates/post.php');

Mais, qu'est-ce que vous avez fait ?! Il est √©trange votre contr√¥leur. Et il n'inclut m√™me pas le mod√®le !

Je vous en avais parl√© : dans un premier temps, je cherche seulement √† tester que mon affichage correspond √† mes attentes. Vous n'avez pas encore besoin de donn√©es dynamiques √† ce stade et √ßa ne vous co√ªte presque pas de temps de cr√©er ces variables manuellement. Maintenant, si vous allez sur la page/post.phpdans votre navigateur, vous pouvez v√©rifier : votre page de billet affiche bien l'article, suivi des commentaires !
La page de l'article affiche avec quelques commentaires !
Cette page est magnifique, m√™me si elle contient de fausses donn√©es !
Dynamisez le contr√¥leur

Notre prochaine √©tape, c'est de faire en sorte que notre contr√¥leur soit encore plus puissant ! (Pas difficile, vu ce qu'on a fait pour le moment).

D√©j√†, on veut qu'il prenne en param√®tre un billet pr√©cis. Il va falloir modifier les liens pr√©sents sur la page d'accueiltemplates/homepage.php, √† la ligne 24, pour y renseigner notre nouvelle URL. On choisit d'utiliser le param√®tre GET intitul√©idpour faire passer l'information √† notre nouveau contr√¥leur.

<!-- templates/homepage.php:24 -->

 

<em><a href="post.php?id=<?= urlencode($post['identifier']) ?>">Commentaires</a></em>

On a besoin d'une nouvelle propri√©t√©identifierau niveau de chaque$postde notre page d'accueil. Et on va directement demander √† notre mod√®le de nous la donner :

<?php

// src/model.php:15

 

$post = [

    'title' => $row['title'],

    'french_creation_date' => $row['french_creation_date'],

    'content' => $row['content'],

    'identifier' => $row['id'],

];

Quand vous cliquez sur les liens "Commentaires" de la page d'accueil, vous acc√©dez dor√©navant √† votre nouvelle page !

Modifions maintenant le contr√¥leurpost.phppour prendre en compte ce param√®tre GET :

<?php

// post.php

 

require('src/model.php');

 

if (isset($_GET['id']) && $_GET['id'] > 0) {

    $identifier = $_GET['id'];

} else {

    echo 'Erreur : aucun identifiant de billet envoy√©';

 

    die;

}


$post = getPost($identifier);

$comments = getComments($identifier);


require('templates/post.php');

Il fait un test, un contr√¥le : il v√©rifie qu'on a bien re√ßu en param√®tre un id dans l'URL ($_GET['id']).

Ensuite, il appelle les 2 fonctions du mod√®le dont on va avoir besoin :getPostetgetComment. On r√©cup√®re √ßa dans nos deux variables. Bien s√ªr, on attend du mod√®le qu'il nous renvoie les m√™mes propri√©t√©s que celles qu'on avait d√©finies :

    title,french_creation_dateetcontentpour les billets ;

    author,french_creation_dateetcommentpour les commentaires.

Si vous testiez votre code tout de suite, il ne fonctionnerait plus. On a demand√© de l'aide au mod√®le, mais on n'a pas encore impl√©ment√© ces fonctions !
Mettez √† jour le mod√®le

Tout d'abord, ajoutons une table pour g√©rer les commentaires dans la base. Elle aura cette structure :
La structure de la table comments
La structure de la table comments

Si vous avez r√©cup√©r√© la bonne √©tiquette Git, vous pouvez supprimer le contenu de votre base de donn√©es et rejouer le fichierdb.sqlpour avoir directement tout √† jour. Sinon, ajoutez-la dans votre base de donn√©es manuellement (en passant par phpMyAdmin par exemple).

Maintenant, concentrons-nous sur le code du mod√®le. Pour l'instant, notre fichiersrc/model.phpne contient qu'une seule fonctiongetPostsqui r√©cup√®re tous les derniers posts de blog.

On va √©crire 2 nouvelles fonctions :

    getPost(au singulier !), qui r√©cup√®re un post pr√©cis en fonction de son ID ;

    getComments, qui r√©cup√®re les commentaires associ√©s √† un ID de post.

Cela donne :

<?php

// src/model.php


function getPosts()

{

    // ... (d√©j√† √©crite)

}


function getPost($identifier) {

    try {

        $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

    } catch(Exception $e) {

        die('Erreur : '.$e->getMessage());

    }

 

    $statement = $database->prepare(

        "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

    );

    $statement->execute([$identifier]);

 

    $row = $statement->fetch();

    $post = [

        'title' => $row['title'],

        'french_creation_date' => $row['french_creation_date'],

        'content' => $row['content'],

    ];

 

    return $post;

}


function getComments($identifier)

{

    try {

        $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

    } catch(Exception $e) {

        die('Erreur : '.$e->getMessage());

    }

 

    $statement = $database->prepare(

        "SELECT id, author, comment, DATE_FORMAT(comment_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM comments WHERE post_id = ? ORDER BY comment_date DESC"

    );

    $statement->execute([$identifier]);

 

    $comments = [];

    while (($row = $statement->fetch())) {

        $comment = [

            'author' => $row['author'],

            'french_creation_date' => $row['french_creation_date'],

            'comment' => $row['comment'],

        ];

        $comments[] = $comment;

    }


    return $comments;

}

Ces deux nouvelles fonctions prennent un param√®tre : l'identifiant du billet qu'on recherche. Cela nous permet notamment de ne s√©lectionner que les commentaires li√©s au post concern√©.

Hum, mais il y a quelque chose qui me d√©range ici. ü§î

Je n'aime pas voir du code se r√©p√©ter. C'est le cas en particulier de la connexion √† la base de donn√©es avec les blocs try/catch. Allez, on va factoriser √ßa !

Je vous propose tout simplement de cr√©er une fonctiondbConnect()qui va renvoyer la connexion √† la base de donn√©es. Je l'ajoute √† la fin du fichier :

<?php

// src/model.php


function getPosts() {

    $database = dbConnect();

    $statement = $database->query(

        "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts ORDER BY creation_date DESC LIMIT 0, 5"

    );

    $posts = [];

    while (($row = $statement->fetch())) {

        $post = [

            'title' => $row['title'],

            'french_creation_date' => $row['french_creation_date'],

            'content' => $row['content'],

            'identifier' => $row['id'],

        ];


        $posts[] = $post;

    }


    return $posts;

}


function getPost($identifier) {

    $database = dbConnect();

    $statement = $database->prepare(

        "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

    );

    $statement->execute([$identifier]);


    $row = $statement->fetch();

    $post = [

        'title' => $row['title'],

        'french_creation_date' => $row['french_creation_date'],

        'content' => $row['content'],

    ];


    return $post;

}


function getComments($identifier)

{

    $database = dbConnect();

    $statement = $database->prepare(

        "SELECT id, author, comment, DATE_FORMAT(comment_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM comments WHERE post_id = ? ORDER BY comment_date DESC"

    );

    $statement->execute([$identifier]);


    $comments = [];

    while (($row = $statement->fetch())) {

        $comment = [

            'author' => $row['author'],

            'french_creation_date' => $row['french_creation_date'],

            'comment' => $row['comment'],

        ];


        $comments[] = $comment;

    }


    return $comments;

}


// Nouvelle fonction qui nous permet d'√©viter de r√©p√©ter du code

function dbConnect()

{

    try {

        $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');


        return $database;

    } catch(Exception $e) {

        die('Erreur : '.$e->getMessage());

    }

}

Ah, c'est tout b√™te, mais je me sens d√©j√† un peu mieux. üòÖ

En fait, c'est encore am√©liorable car actuellement on fait une connexion √† la base de donn√©es pour chaque nouvelle requ√™te. Mais ne nous pr√©cipitons pas et sachons d√©j√† appr√©cier le code qu'on a sous les yeux. On pourra toujours l'am√©liorer plus tard. üòä

Testez, √ßa doit fonctionner !
R√©capitulons en vid√©o

Qu'il reste encore quelques soucis ou que vous souhaitiez juste √™tre s√ªr d'avoir bien compris certains points, je vous conseille de regarder ce screencast, qui reprend point par point toutes les modifications qu'il faut apporter √† votre projet durant ce chapitre.
En r√©sum√©

Nous avons maintenant les fichiers suivants :

    src/model.php: le mod√®le, qui contient diff√©rentes fonctions pour r√©cup√©rer des informations dans la base.

    index.php: le contr√¥leur de la page d'accueil. Il fait le lien entre le mod√®le et la vue.

    templates/homepage.php: la vue de la page d'accueil. Elle affiche la page.

    post.php: le contr√¥leur d'un billet et ses commentaires. Il fait le lien entre le mod√®le et la vue.

    templates/post.php: la vue d'un billet et ses commentaires. Elle affiche la page.
