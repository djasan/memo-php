Ce chapitre utilise le code source r√©cup√©rable en zip sur le Github ou avec l'√©tiquette Gitdonnez-vie-structures, dont voici le lien Github. Est-ce qu'il correspond √† ce que vous aviez produit pour l'exercice du chapitre pr√©c√©dent ?

Alors, ce fameux probl√®me de connexions r√©p√©t√©es √† la base de donn√©es √† chaque requ√™te SQL. Vous vous souvenez de quoi il s'agissait ?

Prenez le fichiersrc/model/post.php. Vous avez la fonctiongetPost()√† la ligne 30 :

<?php


// ...

function getPost($identifier): Post {

    $database = dbConnect();

    $statement = $database->prepare(

        "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

    );

    $statement->execute([$identifier]);


    $row = $statement->fetch();

    $post = new Post();

    $post->title = $row['title'];

    $post->frenchCreationDate = $row['french_creation_date'];

    $post->content = $row['content'];

    $post->identifier = $row['id'];


    return $post;

}


function dbConnect()

{

    $database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');


    return $database;

}

Si votre code appelle deux fois cette fonction, alors la fonctiondbConnectva √™tre appel√©e deux fois aussi. √Ä chaque fois, une nouvelle connexion √† la base de donn√©es sera n√©goci√©e. Se connecter √† une base de donn√©es, c'est une op√©ration lourde, qui prend du temps. Il faut le faire le moins possible.
Encapsulez la connexion √† la base de donn√©es

Je sais, je sais ! Dans le premier chapitre, vous nous avez parl√© de structures. Donc ce qu'il faudrait, c'est une structure qui contienne la connexion √† la base de donn√©es, si elle existe, et qu'on passerait en param√®tre √† chaque fonction. C'est bien √ßa ?

Vous avez l'esprit vif, bravo ! Faisons-√ßa tout de suite dans notre fichiersrc/model/post.php:

<?php


class Post

{

    public string $title;

    public string $frenchCreationDate;

    public string $content;

    public string $identifier;

}


class PostRepository

{

    public ?PDO $database = null;

}


function getPosts(PostRepository $repository): array {

    dbConnect($repository);

    $statement = $repository->database->query(

        "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts ORDER BY creation_date DESC LIMIT 0, 5"

    );

    $posts = [];

    while (($row = $statement->fetch())) {

        $post = new Post();

        $post->title = $row['title'];

        $post->frenchCreationDate = $row['french_creation_date'];

        $post->content = $row['content'];

        $post->identifier = $row['id'];


        $posts[] = $post;

    }


    return $posts;

}


function getPost(PostRepository $repository, string $identifier): Post {

    dbConnect($repository);

    $statement = $repository->database->prepare(

        "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

    );

    $statement->execute([$identifier]);


    $row = $statement->fetch();

    $post = new Post();

    $post->title = $row['title'];

    $post->frenchCreationDate = $row['french_creation_date'];

    $post->content = $row['content'];

    $post->identifier = $row['id'];


    return $post;

}


function dbConnect(PostRepository $repository)

{

    if ($repository->database === null) {

        $repository->database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

    }

}

Alors, r√©sumons ce qui a √©t√© fait :

    Vous avez √©crit une classePostRepository√† la ligne 11. Elle a une propri√©t√© nullable nomm√©e$database, qui repr√©sente une potentielle connexion avec une base de donn√©es. Le typePDO, c'est le type de la connexion SQL sous-jacente. D'ailleurs, vous aviez remarqu√© que c'√©tait un type d'objet personnalis√© aussi ? Il est simplement fourni par un module PHP.

    Le param√®trePostRepository $repositorya √©t√© ajout√© √† chaque fonction, aux lignes 16 et 35. √áa permet d'avoir la connexion √† la base de donn√©es, si elle existe, dans le contexte d'ex√©cution de nos fonctions.

    La fonctiondbConnect()re√ßoit aussi unPostRepository√† la ligne 52. Mais elle, c'est plut√¥t pour le modifier. C'est elle qui va √™tre responsable d'initialiser la connexion √† la base de donn√©es la premi√®re fois. Vous noterez que vous avez le droit de changer la valeur des propri√©t√©s d'un objet pass√© en param√®tre d'une fonction, et que √ßa va impacter l'objet partout o√π il est utilis√© par la suite. M√™me dans les fonctions parentes !

Bon, et si nous reprenions tout √ßa avec un screencast ? Il y a quand m√™me un bon nombre de modifications, je vais vous les d√©rouler.
Utilisez des m√©thodes

C'est une premi√®re √©tape. Mais malheureusement, en l'√©tat, je vois deux probl√®mes √† notre code :

    D√©j√†, on r√©p√®te le param√®trePostRepository $repositoryde partout. C'est verbeux, donc un code moins agr√©able √† √©crire. C'est un signe qui ne trompe pas en programmation : vous avez affaire √† un contexte.

    Et puis, les$repositorypass√©s en param√®tre devront √™tre initialis√©s par une autre couche de code : le contr√¥leur. Nous, on pr√©f√®rerait que le mod√®le soit autonome.

Eh bien, vous savez quoi ? Comme face √† la plupart des probl√®mes r√©currents en programmation, des solutions ont d√©j√† √©t√© imagin√©es.

En PHP, comme dans la plupart des langages orient√©s objet, il est possible de demander √† un objet d'ex√©cuter du code, en autonomie compl√®te, dans son propre contexte !

Attendez... Ne me dites pas que √ßa r√©soudrait nos deux probl√®mes directement ?!

Mais si, je vous le dis ! L'id√©e, c'est qu'une classe peut d√©finir des fonctions, qu'elle saura ex√©cuter d'elle-m√™me. Ces fonctions particuli√®res s'appellent les m√©thodes de la classe. Et toutes les m√©thodes auront directement acc√®s √† l'instance actuelle, comme contexte, via la variable magique$this. Je vous montre comment on d√©clare une m√©thode avec notrePostRepositoryetgetPost():

<?php


// ...

class PostRepository

{

    public ?PDO $database = null;


    public function getPost(/* PostRepository $this, */string $identifier): Post

    {

        dbConnect($this);

        $statement = $this->database->prepare(

            "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

        );

        $statement->execute([$identifier]);


        $row = $statement->fetch();

        $post = new Post();

        $post->title = $row['title'];

        $post->frenchCreationDate = $row['french_creation_date'];

        $post->content = $row['content'];

        $post->identifier = $row['id'];


        return $post;

    }

}

// ...

On a d√©plac√© la fonctiongetPost()√† l'int√©rieur de la d√©claration de notre classe. Et automatiquement, c'est comme si elle recevait en premier param√®tre sa propre instance dePostRepository, nomm√©e$this.

Ok, √ßa semble prometteur. Mais comment je dois utiliser cette "m√©thode", moi ?

Les m√©thodes d'un objet s'utilisent presque de la m√™me fa√ßon que ses propri√©t√©s : avec l'op√©rateur fl√®che->. Reprenons le fichiersrc/controllers/post.php, nous allons faire la premi√®re ensemble :

<?php


require_once('src/model/post.php');

require_once('src/model/comment.php');


function post(string $identifier)

{

    $postRepository = new PostRepository();

    $post = $postRepository->getPost($identifier);

    $comments = getComments($identifier);


    require('templates/post.php');

}

Premi√®rement, vous cr√©ez une instance de votre objetPostRepository, qui contiendra sa propre connexion √† la base de donn√©es. Normalement, vous ma√Ætrisez cette partie l√†.

Deuxi√®mement, vous utilisez$postRepository->getPost($identifier)pour demander √† votre objet de vous faire parvenir le bon billet de blog.

Chaque instance d'une m√™me classe a son propre cycle de vie ! Vous pouvez cr√©er 3PostRepository, et chacun fera sa propre connexion √† la base de donn√©es au moment o√π vous lui demanderezgetPost(). Le$this√† l'int√©rieur de la m√©thode correspondra toujours √† l'objet sur lequel vous appelez la m√©thode. Chaque objet est autonome ! ü•∞

Et si on reprenait ces √©tapes en vid√©o ? C'est parti pour un nouveau screencast !
Finalisez la refactorisation des billets

Pour le moment, le code de notre fichiersrc/model/post.phpest dans un √©tat un peu brouillon. Une m√©thode dans la classe et deux fonctions en dehors. Vous allez harmoniser tout √ßa, en transformant les deux fonctions en m√©thodes de classePostRepository. Je vous laisse effectuer la modification et je vous mettrai le code final juste apr√®s.

Voici mon fichiersrc/model/post.phpapr√®s modification :

<?php


class Post

{

    public string $title;

    public string $frenchCreationDate;

    public string $content;

    public string $identifier;

}


class PostRepository

{

    public ?PDO $database = null;


    public function getPost(string $identifier): Post

    {

        $this->dbConnect();

        $statement = $this->database->prepare(

            "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts WHERE id = ?"

        );

        $statement->execute([$identifier]);


        $row = $statement->fetch();

        $post = new Post();

        $post->title = $row['title'];

        $post->frenchCreationDate = $row['french_creation_date'];

        $post->content = $row['content'];

        $post->identifier = $row['id'];


        return $post;

    }


    public function getPosts(): array

    {

        $this->dbConnect();

        $statement = $this->database->query(

            "SELECT id, title, content, DATE_FORMAT(creation_date, '%d/%m/%Y √† %Hh%imin%ss') AS french_creation_date FROM posts ORDER BY creation_date DESC LIMIT 0, 5"

        );

        $posts = [];

        while (($row = $statement->fetch())) {

            $post = new Post();

            $post->title = $row['title'];

            $post->frenchCreationDate = $row['french_creation_date'];

            $post->content = $row['content'];

            $post->identifier = $row['id'];


            $posts[] = $post;

        }


        return $posts;

    }


    public function dbConnect()

    {

        if ($this->database === null) {

            $this->database = new PDO('mysql:host=localhost;dbname=blog;charset=utf8', 'blog', 'password');

        }

    }

}

 L'astuce ici √©tait d'utiliser$this->dbConnect()!$thisrepr√©sentant un objet, on peut aussi l'utiliser pour appeler d'autres m√©thodes sur lui-m√™me. Et bien s√ªr, il a fallu aussi modifier le fichiersrc/controllers/homepage.php, pour qu'il utilise √† son tour unPostRepository:

<?php


require_once('src/model/post.php');


function homepage()

{

    $postRepository = new PostRepository();

    $posts = $postRepository->getPosts();


    require('templates/homepage.php');

}

En r√©sum√©

    On peut encapsuler des donn√©es dans des objets personnalis√©s, pour impl√©menter des cycles de vie complexes.

    Les classes peuvent contenir des m√©thodes dans leur d√©finition. Ce sont des fonctions qui re√ßoivent automatiquement la variable$this, contenant l'instance actuelle de la classe. Elles s'utilisent comme les propri√©t√©s, avec l'op√©rateur fl√®che->sur l'objet souhait√© :$object->method();.

    Chaque objet a son propre cycle de vie. Appeler une m√©thode sur un objet, c'est demander √† cet objet d'effectuer une action sur lui-m√™me. Il n'impactera jamais les autres instances de la classe.
