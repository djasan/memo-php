D√©couvrons une fonctionnalit√© bien utile du langage SQL : les fonctions.

En effet, le langage SQL permet d'effectuer des calculs directement sur ses donn√©es, √† l'aide de fonctions toutes pr√™tes.

Celles-ci sont moins nombreuses qu'en PHP, mais elles sont sp√©cialement d√©di√©es aux bases de donn√©es, et se r√©v√®lent tr√®s puissantes dans la pratique.

Ainsi, en effectuant directement certains calculs en SQL plut√¥t qu'en PHP, nous all√©geons un petit peu la quantit√© de code √† √©crire.

Nous allons mettre en application deux cas d'utilisation qui compl√®teront votre projet :

    R√©cup√©rer et afficher la moyenne des notes obtenues pour une recette.

    Am√©liorer les commentaires en ajoutant une date de publication.

Les fonctions SQL peuvent √™tre class√©es en deux cat√©gories :

    Les fonctions scalaires : elles agissent sur chaque entr√©e. Par exemple, vous pouvez transformer en majuscules la valeur de chacune des entr√©es d'un champ.

    Les fonctions d'agr√©gat : lorsque vous utilisez ce type de fonctions, des calculs sont faits sur l'ensemble de la table pour retourner une valeur. Par exemple, calculer la moyenne des prix retourne une valeur : le prix moyen.

Utilisez une fonction scalaire SQL

Voyons d'abord le mode d'emploi d'une fonction SQL de type scalaire : la fonction  

DATE_FORMAT

Lorsque vous aurez appris √† vous en servir, vous serez capable de faire de m√™me avec toutes les autres fonctions scalaires.

Pour nos exemples, nous allons nous baser sur la table comments  que nous connaissons bien maintenant.

Pour rappel, voici √† quoi elle pourrait ressembler, en consid√©rant les commentaires sur la recette qui a pour identifiant unique la valeur 1 :

comment_id
	

user_id
	

recipe_id
	

comment
	

created_at
	

review

1
	

1
	

1
	

Bof üòê
	

2021-07-16 13:56:48
	

2

2
	

3
	

1
	

Pas bon du tout ! ü§¢
	

2021-07-14 18:27:32
	

0

3
	

2
	

1
	

Super recette üòç
	

2021-07-12 16:12:00
	

5

4
	

...
	

...
	

 
	

...
	

...

On √©crit les noms des fonctions SQL en majuscules, comme on le fait d√©j√† pour la plupart des mots-cl√©s comme SELECT  , INSERT  , etc.

Ce n'est pas une obligation mais plut√¥t une convention, une habitude qu'ont prise les programmeurs.

Pour vous montrer comment on utilise les fonctions scalaires SQL, je vais me baser sur la fonction DATE_FORMAT()  qui permet de convertir un timestamp en date.

La requ√™te SQL suivante va convertir la date obtenue en quelque chose de lisible :

SELECT *, DATE_FORMAT(c.created_at, "%d/%m/%Y") FROM recipes r LEFT JOIN comments c on r.recipe_id = c.recipe_id WHERE r.recipe_id = 1

√Ä l'aide de cette fonction, nous r√©cup√©rons directement la date au format jour/mois/ann√©e plut√¥t que les heures/minutes/secondes qui ne nous int√©ressent pas.

Cela modifie-t-il le contenu de la table ?

Non ! La table reste la m√™me.

La fonction DATE_FORMAT modifie seulement la valeur envoy√©e √† PHP. On ne touche donc pas au contenu de la table.

Cela cr√©e en fait un ¬´ champ virtuel ¬ª qui n'existe que le temps de la requ√™te. Il est conseill√© de donner un nom √† ce champ virtuel qui repr√©sente les dates de commentaire.

Il faut utiliser pour cela le mot-cl√© AS :

SELECT DATE_FORMAT(c.created_at, "%d/%m/%Y") AS comment_date FROM recipes r LEFT JOIN comments c on r.recipe_id = c.recipe_id WHERE r.recipe_id = 1

On r√©cup√®re les dates de commentaires via un champ virtuel appel√© comment_date  .

Ce champ virtuel est appel√© "alias".

Voici le tableau que retournera MySQL apr√®s la requ√™te pr√©c√©dente :

comment_date

16/07/2021

14/07/2021

12/07/2021

PHP ne r√©cup√®re que le champ nomm√© comment_date  (m√™me s'il n'existe pas dans la table).

En affichant le contenu de ce champ, on ne r√©cup√®re que les dates de publication des commentaires correctement format√©es.

Bien entendu, vous pouvez aussi r√©cup√©rer le contenu des autres champs comme avant, sans forc√©ment leur appliquer une fonction :

SELECT *, DATE_FORMAT(c.created_at, "%d/%c/%Y") AS comment_date FROM recipes r LEFT JOIN comments c on r.recipe_id = c.recipe_id WHERE r.recipe_id = 1

Vous savez maintenant utiliser une fonction SQL scalaire !

Pour une liste des fonctions scalaires les plus pratiques, consultez le chapitre "les fonctions scalaires" du cours MySQL.

Vous apprendrez plus sur les fonctions de manipulation des dates dans un autre chapitre de ce m√™me cours.
Utilisez une fonction d'agr√©gat

Comme pr√©c√©demment, nous allons d'abord voir comment on utilise une fonction d'agr√©gat dans une requ√™te SQL. L'essentiel est de comprendre comment s'utilise ce type de fonctions : vous pourrez ensuite appliquer ce que vous connaissez √† n'importe quelle autre fonction du m√™me type.

Ces fonctions diff√®rent assez des pr√©c√©dentes. Plut√¥t que de modifier des valeurs une √† une, elles font des op√©rations sur plusieurs entr√©es pour retourner une seule valeur.

Par exemple, ROUND()  est une fonction scalaire qui permet d'arrondir une valeur. On r√©cup√®re donc autant d'entr√©es qu'il y en avait dans la table. En revanche, une fonction d'agr√©gat comme AVG() renvoie une seule entr√©e : la valeur moyenne de tous les lignes.

Regardons de pr√®s la fonction d'agr√©gat  AVG  .

Elle calcule la moyenne d'un champ contenant des nombres.

Utilisons-la sur le champ review qui ‚Äì pour rappel ‚Äì permet √† l'utilisateur d'√©valuer une recette avec l'identifiant unique  1  :

SELECT AVG(c.review) as rating FROM recipes r LEFT JOIN comments c on r.recipe_id = c.recipe_id WHERE r.recipe_id = 1

On donne l√† encore un alias au r√©sultat donn√© par la fonction. La particularit√©, c'est que cette requ√™te ne va retourner qu'une seule entr√©e, √† savoir l'√©valuation moyenne de la recette :

rating

2.33333

Mais c'est super moche, on peut pas calculer un arrondi de la moyenne ?

Si ! Tout comme en PHP on peut appeler une fonction dans une fonction, ici on va pouvoir appliquer la fonction ROUND() avec 1 d√©cimale sur le r√©sultat du calcul de la moyenne !

La requ√™te devient donc la suivante :

SELECT ROUND(AVG(c.review),1) as rating FROM recipes r LEFT JOIN comments c on r.recipe_id = c.recipe_id WHERE r.recipe_id = 1

Pour afficher cette information en PHP, on pourrait faire comme on en a l'habitude (cela fonctionne). Mais pourquoi s'emb√™terait-on √† faire une boucle, √©tant donn√© qu'on sait qu'on ne va r√©cup√©rer qu'une seule entr√©e, puisqu'on utilise une fonction d'agr√©gat ?

<?php

$sqlQuery = 'SELECT ROUND(AVG(c.review),1) as rating FROM recipes r LEFT JOIN comments c on r.recipe_id = c.recipe_id WHERE r.recipe_id = 1';


// Pr√©paration

$averageRatingStatment = $db->prepare($sqlQuery);


// Ex√©cution

$averageRatingStatment->execute();


/** La fonction fetch est plus performante que fetchAll()

 * quand nous sommes certain(e)s de ne r√©cup√©rer qu'une ligne.

 * https://www.php.net/manual/fr/pdostatement.fetch.php

 */

$averageRating = $averageRatingStatment->fetch();

Ce code est plus simple et plus logique :

    On r√©cup√®re la premi√®re et seule entr√©e avec fetch()  .

    Et on affiche ce qu'elle contient. Inutile de le faire dans une boucle, √©tant donn√© qu'il n'y a pas de seconde entr√©e.

Ne m√©langez pas une fonction d'agr√©gat avec d'autres champs

Soyez attentif √† ce point car il n'est pas forc√©ment √©vident √† comprendre :

Vous ne devez pas r√©cup√©rer d'autres champs de la table quand vous utilisez une fonction d'agr√©gat, contrairement √† tout √† l'heure avec les fonctions scalaires.

En effet, quel sens cela aurait-il de faire :

# Requ√™te qui provoque une erreur !

SELECT AVG(review) AS rating, user_id FROM comments

On r√©cup√©rerait d'un c√¥t√© la note moyenne de tous les commentaires et de l'autre la liste des auteurs de ces commentaires‚Ä¶ Il est impossible de repr√©senter ceci dans un seul et m√™me tableau.

Comme vous le savez, SQL renvoie les informations sous la forme d'un tableau. Or, on ne peut pas repr√©senter la moyenne des notes (qui tient en une seule entr√©e) en m√™me temps que la liste des auteurs. Si on voulait obtenir ces deux informations, il faudrait faire deux requ√™tes.

C'est d'ailleurs ce qui est fait dans le projet fil rouge pour r√©cup√©rer √† la fois les commentaires et la note moyenne d'une recette !

Pour une liste des fonctions d'agr√©gat les plus pratiques, consultez le chapitre "les fonctions d'agr√©gation" du cours MySQL.
Regroupez des donn√©es avec GROUP BY et HAVING

Je vous disais un peu plus t√¥t qu'on ne pouvait pas r√©cup√©rer d'autres champs lorsqu'on utilisait une fonction d'agr√©gat.

Prenons par exemple la requ√™te suivante :

SELECT AVG(review) AS rating, user_id FROM comments

√áa n'a pas de sens de r√©cup√©rer la note moyenne de toutes les recettes et le  ¬´ User ID ¬ª √† la fois. MySQL ne peut pas renvoyer un tableau correspondant √† ces informations-l√†.
Groupez des donn√©es avec GROUP BY

En revanche, ce qui pourrait avoir du sens, ce serait de demander le note moyenne des commentaires pour chaque recette !

Pour faire cela, on doit utiliser un nouveau mot-cl√© : GROUP BY qui signifie ¬´ grouper par ¬ª.

On utilise cette clause en combinaison d'une fonction d'agr√©gat (comme AVG ) pour obtenir des informations int√©ressantes sur des groupes de donn√©es.

Voici un exemple d'utilisation de GROUP BY :

SELECT AVG(review) AS rating, recipe_id FROM comments GROUP BY recipe_id

Il faut utiliser GROUP BY  en m√™me temps qu'une fonction d'agr√©gat, sinon il ne sert √† rien.

Ici, on r√©cup√®re la note moyenne des commentaires, que l'on regroupe ensuite par recette. Par cons√©quent, on obtiendra la liste des recettes de la table et la note moyenne des commentaires !

rating
	

recipe_id

2.50
	

1

3.00
	

2

4.50
	

3

Cette fois, les valeurs sont coh√©rentes !
Filtrez les donn√©es regroup√©es avec HAVING

HAVING  est un peu l'√©quivalent de WHERE  , mais il agit sur les donn√©es une fois qu'elles ont √©t√© regroup√©es. C'est donc une fa√ßon de filtrer les donn√©es √† la fin des op√©rations.

Voyez la requ√™te suivante :

SELECT AVG(review) AS rating, recipe_id FROM comments GROUP BY recipe_id HAVING rating >= 3

Avec cette requ√™te, on r√©cup√®re seulement les recettes dont la note moyenne est sup√©rieure ou √©gale √† 3.

HAVING  ne doit s'utiliser que sur le r√©sultat d'une fonction d'agr√©gat. Voil√† pourquoi on l'utilise ici sur rating  et non sur recipe_id  .

Je ne comprends pas la diff√©rence entre WHERE  et HAVING  . Les deux permettent de filtrer, non ?

Oui, mais pas au m√™me moment :

    WHERE  agit en premier, avant le groupement des donn√©es ; 

    HAVING  agit en second, apr√®s le groupement des donn√©es.

On peut d'ailleurs tr√®s bien combiner les deux, regardez l'exemple suivant :

SELECT AVG(review) AS rating, recipe_id FROM comments WHERE user_id = 1 GROUP BY recipe_id HAVING rating >= 2

√áa commence √† faire de la requ√™te costaude. üòâ

Ici, on demande √† r√©cup√©rer la note moyenne par recette de Micka√´l ( WHERE  ), dont la valeur moyenne est sup√©rieure ou √©gale √† 2 ( HAVING  ).
En r√©sum√©

    MySQL permet d'ex√©cuter certaines fonctions lui-m√™me, sans avoir √† passer par PHP. Ces fonctions modifient les donn√©es renvoy√©es.

    Il existe deux types de fonctions :

        Les fonctions scalaires : elles agissent sur chaque entr√©e r√©cup√©r√©e. Elles permettent par exemple de convertir tout le contenu d'un champ en majuscules, ou d'arrondir chacune des valeurs.

        Les fonctions d'agr√©gat : elles effectuent des calculs sur plusieurs entr√©es pour retourner une et une seule valeur. Par exemple : calcul de la moyenne, somme des valeurs, comptage du nombre d'entr√©es‚Ä¶

    On peut donner un autre nom aux champs modifi√©s par les fonctions, en cr√©ant des alias √† l'aide du mot-cl√© AS .

    Lorsqu'on utilise une fonction d'agr√©gat, il est possible de regrouper des donn√©es avec GROUP BY .

    Apr√®s un groupement de donn√©es, on peut filtrer le r√©sultat avec HAVING . Il ne faut pas le confondre avec WHERE qui filtre avant le groupement des donn√©es.

C'est la fin de ce cours, merci de l'avoir suivi !

Vous avez maintenant les bases en PHP : bravo, c'est d√©j√† un vrai morceau !

Prenez le temps de refaire les diff√©rentes √©tapes que l'on a vues au cours de notre projet fil rouge.

Ensuite ?

Eh bien vous √™tes loin d'avoir fini : le monde de la programmation est riche, et vous pouvez aller bien plus loin.
Allez plus loin en PHP

Voici ce que je vous recommande de faire apr√®s avoir fini ce cours :

    D√©couvrez comment mieux organiser votre code avec l'architecture MVC (Mod√®le Vue Contr√¥leur). Il s'agit d'une "fa√ßon de programmer" tr√®s connue qui vous permet de bien s√©parer chaque morceau de votre code. Si vous voulez travailler dans un milieu professionnel √† plusieurs, cela vous sera absolument indispensable ! √áa tombe bien, j'ai √©crit un cours l√†-dessus : Adoptez une architecture MVC en PHP ! (C'est en fait la suite de ce cours sur PHP.)

    D√©couvrez comment faire de la programmation orient√©e objet (POO), une autre technique de programmation incontournable. Elle est compl√©mentaire √† MVC : Programmez en orient√© objet en PHP.

    Apprenez √† utiliser un framework PHP comme Symfony. Il vous facilitera grandement le travail pour vos projets professionnels. Il se base sur la POO et MVC ; donc si vous avez suivi les deux cours pr√©c√©dents, vous devriez vous y retrouver bien plus facilement : Construisez un site web avec le framework Symfony 5.


